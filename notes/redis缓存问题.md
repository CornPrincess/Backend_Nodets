## 缓存穿透
缓存穿透是指，在同一时间，有大量的并发请求，这些请求请求的数据都不在缓存中，因此会出现缓存穿透的现象，即大量的请求直接打到数据库上，此时数据库很容易就会被打挂，而数据库一旦挂了，其他访问这个数据库的服务也会一起挂，最终造成所有服务的不可用。
### 解决方法
- 将空数据存入缓存：当请求访问数据库时，即使查不到数据，也将空数据放在缓存中，这样下次请求就会直接访问缓存，这种做法比较简单粗暴，但是有几点需要注意：
  - 对于正常的业务数据，其空值不能存储太长的时间，比如查询id = 1的数据一开始数据库没有，对于在缓存中存储一个空值，但是在1s过后，在数据库中插入了id = 1的值，如果缓存的过期时间设置超过了1s，那么此时按照流程还会去查缓存中的值，就会出现业务问题。
  - 对于不正常的业务数据，如 id < 0 的这种查询，可以将缓存中对应的空值的超时时间设得长一些。
  
- 布隆过滤器： 本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。
              利用布隆过滤器可以将不存在的值直接挡掉。基本原理就是将数据库中的数据搬到布隆过滤器中，比如，查询时会使用到 id，那么把相关的id都存在布隆过滤器上，当请求来了以后，首先通过布隆过滤器进行判断当前数据库是否存在该数据，如果不存在，那么直接返回一个空值，避免了对数据量的高并发。
  - 详细介绍可以看这篇文章： https://zhuanlan.zhihu.com/p/43263751  https://juejin.cn/post/6844903982209449991
  
## 缓存击穿
缓存击穿指某个热点key在某一时刻将要过期，但就在此时，有大量针对这个热点key的请求，此时这些大量的请求就会穿过缓存，直接访问数据库，把数据库打挂。
注意这里缓存击穿的概念和缓存穿透有点像，但他们引起的原因是不同的，缓存穿透是由于数据库中没有这个数据，缓存中根本没有这个数据，造成缓存穿透，但是缓存击穿，是由于数据库中有数据，但是缓存中的热点key过期，才直接访问数据库。
### 解决方法
 - 自动刷新：类似于jwt的自动刷新功能。
  - redis支持查询一个key 的过期时间，我们可以设置，在请求时会进行一个查询过期时间的callback，当过期时间超过一定值时，自动刷新其过期时间。
  - 这也存在一个问题，即在超时时间内都没有请求访问，那么就不会刷新，因此还是存在缓存击穿的风险
 - 定时刷新
  - 定时任务：生成一个定时任务，定时查询要超时的key，这样会比较消耗服务器性能
  - 延迟队列：将数据存入缓存的那一刻同时将该数据发送给一个延迟队列（按指定时间消费），时间小于缓存中key的过期时间，到了指定时间，消费者刷新key的有效时间再将这个数据发送给一个延迟队列，以此循环，这种方式还是不错的，但是实现方式相对于第一种来说就要复杂一点了，他需要依靠消息中间件来完成，如果消息中间件某个时间宕机，那就gg了，虽然这种方式虽然比较推荐，但是成本偏高，因为为了防止消息中间件宕机，我们有可能需要对消息中间件做集群处理。
  - 程序加锁：使用读写锁，即线程访问缓存时使用读锁，这样可以支持高并发，但是线程访问数据库时使用写锁，这样可以保证在一个时刻只有一个线程，当这个线程写完以后，后面的请求可以都访问缓存而访问数据库。 

## 缓存雪崩
缓存雪崩指缓存中的数据大批量到达了过期时间，雪崩这个词用得很形象，就像雪山发送雪崩一样，此时就会造成大批量的线程都去访问数据库，数据库很容易被打挂。
为什么会出现缓存雪崩的现象？因为设置的超时时间相同
### 解决方法
 - 随机设置超时时间：通过在一个同一个的超时时间上，加上一个比较小的随机数来实现
 - 设置永久有效：将一些经常使用的数据可以设为永久有效，注意这里是一些而不是永久

## 布隆过滤器
布隆过滤器有许多实现与优化，Guava中就提供了一种Bloom Filter的实现。
在使用bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp，
在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的大小。
对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数
