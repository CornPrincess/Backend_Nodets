# 自增与赋值运算符

Java中的自增运算符分为前置自增与后置自增（pre- and post-increment.），通过两道代码题，意识到自己对于它的认识还是很肤浅的。

主要还是记住这两条原则：

> **Post Increment(n++)** : First execute the statement then increase the value by one.
>
> **Pre Increment (++n)** : First increase the value by one then execute the statement.
>
> 前缀形式的运算规则可以概括为：”**先自增(减)，后引用**”，而后缀形式的运算规则可以概括为：”**先引用，后自增(减)**”。这里所说的”引用”，指的是使用变量的值。另外，我们还要强调一个细节：**无论是前缀形式还是后缀形式，自增自减运算符的优先级要高于赋值运算符**。

## 语句中仅有++或--

```java
int a = 2;
int b = 2;
a++;
++b;
System.out.println(a); // 3
System.out.println(b); // 3
```

这种情况比较简单，当语句中仅有++时，此时它在前面或后面基本没什么区别。

## ++ 或者 -- 运算结果赋值给其他变量

```java
int a = 2;
int b = ++a;
System.out.println(a); // 3
System.out.println(b); // 3
```

先看++在前面的情况，根据**先增加后引用**的规则，可以得出a先自增，然后赋值给b，所以两者的结果都是3。

```java
int a = 2;
int b = a++;
System.out.println(a); // 3
System.out.println(b); // 2
```

再看 ++ 在后面的情况，如果按照规则**先引用后自增**的规则，那么结果结果应该a=3， b=2，虽然结果符合预期，**但是容易理解为先赋值后自增，这种理解是错误的，因为 ++ 的优先级大于=，应该先++，后赋值**。

> 当程序中，如果变量参与了算术运算、或者以变量的值进行赋值，或者打印了某个变量的值，**总之只要程序中用到这个变量的值，都会先把这个变量存入一个临时的空间，专业上把这个临时的空间称之为”操作数栈”。我们之前所说的”先引用后自增”中所说的这个”引用”操作，其实就是指”把变量的值存入操作数栈”这个动作。当程序中需要用到变量的值，计算机是从”操作数栈”中取出值进行运算，并不是我们想象的直接从变量所在的内存单元中取出数值。但是，如果语句中仅有++或--，并不会把变量的值存入操作数栈，而是直接对变量进行自增或自减的操作，这也是为什么我们把语句中仅有++或--单独作为一种情况讲解的原因。**

在这里属于**先引用后自增**，因此，计算机会先取出a的值存入操作数栈，然后再把a的值增加到3，**做完这个自增的操作后，接下来会对变量b进行赋值操作，此时的赋值操作用的是刚才存在操作数栈上的值，即2，对b进行赋值。所以最终结果b=2.**

```java
int a = 2;
int b = ++a + ++a;
System.out.println(a); // 4
System.out.println(b); // 7
```

再来看这个例子，首先明确优先级，从高到低依次是：++，+， =

我们分析第二行代码

- 第一个++a先自增为3，随后将3存入操作数栈1
- 第二个++a先自增为4，随后将4存入操作数栈2
- 进行 3 + 4加法运行，得出7，赋值给b

```java
int a = 2;
int b = ++a + a++ + ++a;
System.out.println(a); // 5
System.out.println(b); // 11
```

再来看一个稍微复杂的式子，我们分析第二行代码过程

- 第一个++a先自增为3，随后将3存入操作数栈1
- 第二个 a++ 先将3存入操作数栈2，随后自增为4
- 进行 3 + 3运算，将结果6存入操作数栈3
- 第三个 ++a 先自增为5，随后将5放入操作数栈4
- 进行 6 + 5 运算，将11赋值给b

对于第三步，作者给出的解释

> 很多同学肯定都会认为计算机肯定是先去完成a的第3次自增操作，理由是自增自减运算优先级高于加法运算。其实不然，当运算进行到这一步的时候，计算机会先把”栈1”和”栈2”中的两个值相加，然后才去完成a的第3次自增操作。很多人都不理解为什么会这样，难道不是++a的优先级更高吗？
>
> 这里需要澄清一个大家对”优先级”概念的误解。当计算机有AB两个操作可以做的时候，如果选择先完成A得到的结果是X，而选择先完成B得到结果是Y，此时计算机必须按照运算的优先级做出选择。而如果先完成A和先完成B对运算结果没有影响，那么计算机就会先完成左边(先出现的)的操作。此时，如果把”栈1”和”栈2”中的值相加，并不会影响到最终的运算结果，并且这个操作是先于”a的第3次自增”出现的，所以计算机会先把”栈1”和”栈2                                                                                                                                                                   ”中的值加起来，然后才完成”a的第3次自增.

## ++或--运算结果赋值给自身

```java
int a = 2;
a = ++a;
System.out.println(a); // 3
```

这个例子中代码先自增，后引用，即把3放入操作数栈中，此时把3赋值给a，a最终值为3.

```java
int a = 2;
a = a++;
System.out.println(a); // 2
```

这个例子中，a先引用，即把2放入操作数栈中，然后自增为3，最后把操作数栈中的2赋值给a，a的结果为2。

我们可以看一下的例子加深理解

```java
int a = 2;
a = ++a + a++;
System.out.println(a); // 6
int b= 2;
b += ++b + ++b;
System.out.println(b); // 9
```

这里用到了复合赋值运算符，**当语句中用复合赋值运算符给变量赋值当时候，计算机会先把复合赋值运算符左边变量的值存入操作数栈**。因此，上述b的值为9

```java
public static void main(String[] args) {
  int i = 1;
  int j = i++; // j = 1, i = 2
  if ((i == (++j))  && ((i++) == j)) {
    // after compare, i =3, j = 2
    i += j;
  }
  System.out.println(i);
}
```

在这个例子中 if 判断条件成立，因为 ++i 先运算 后判断，i++先判断，后运算

## Reference

1. [学透自增自减运算符](https://zhuanlan.zhihu.com/p/103446936)

