# Java内存模型

## 硬件的效率与一致性

先花一点时间了解下物理计算机中的并发问题。物理机遇到的并发问题与虚拟机中断情况有很多相似之处，物理机对并发的处理方案对虚拟机的实现也有相当大的参考意义。

> 绝大多数的运算任务都不可能只靠处理器“计算”就能完成。处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作就是很难消除的（无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：缓存一致性（Cache Coherence）。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），这种系统称为共享内存多核系统（Shared Memory Multiprocessors System）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。

![memory and CPU and Cache](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/memoryAndCacheAndCPU.png)

如果真的发生这种情况，那**同步回到主内存时该以谁的缓存数据为准呢**？为了解决一致性的问题，**需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作**，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。从本章开始，我们将会频繁见到**“内存模型”一词，它可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。**不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且与这里介绍的内存访问操作及硬件的缓存访问操作具有高度的可类比性。

除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被重复利用，**处理器可能会对输入的代码进行乱序执行（out-of-order Execution），处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句的先后顺序与输入代码中的顺序一致。因此如果存在一个计算任务依赖另外一个计算任务的*中间结果*，那么其顺序性并不能靠代码的先后顺序来保证。**与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有**指令重排序（Instruction Reorder）**优化。

## Java内存模型

《Java虚拟机规范》中曾试图定义一种**“Java内存模型”（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。**在此之前，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序。

经过长时间的验证和修补，直至**JDK 5（实现了JSR-133）**发布后，Java内存模型才终于成熟、完善起来了。

### 主内存和工作内存

**Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量存储到内存和从内存中取出变量值这样的底层细节。**

> 此处的变量（Variables）与Java编程中所说的变量有所区别，**它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数(如果局部变量是reference引用类型，它引用的对象在Java堆中可以被各个线程共享，但是reference本身在Java栈的局部变量表中是线程私有的)**，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得更好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。

Java内存模型规定了所有的变量都存储在主内存（main memory）中（此处的主内存与接收物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它近视虚拟机内存的一部分）。每条线程还有自己的工作内存（working memory，可与前面将的处理器高速缓存类比）。

> 主内存中的变量即上文提到的实例字段、静态字段和构成数组的元素。

线程的工作内存中保存了该线程使用的变量的主内存副本（注意理解这个副本的概念，如果线程要访问10M的对象，它不会把它复制一份，但这个对象的引用，对象中某个在线程访问到的字段是有可能复制的，但不会有虚拟机把整个对象复制一次）。**线程对变量的所有操作（读取，赋值）等必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方工作内存中的变量，线程键变量值的传递均需要通过主内存来完成。**

> 需要注意的是这里将的主内存，工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分，这两者是没有任何关系的。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。
>
> 摘自：《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 — 周志明

### 内存间交互操作

关于主内存与工作内存之间具体的交互协议，**即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节**，Java内存模型中定义了8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外。后来Java设计团队大概也意识到了这个问题，将Java内存模型的操作简化为read、write、lock和unlock四种。



### 原子性、可见性和有序性

并发编程绕不开同步和通信的问题，我们先看同步的问题。Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特性来建立的。

#### 原子性 Atomicity

原子性指一个操作或多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么都不执行。

Java中除了 long 和 double之外，其他基础类型的赋值操作都是原子的， 但是 ++ 和-- 的操作不是原子的

> 由Java内存模型来直接保证的原子性变量操作包括`read`、`load`、`assign`、`use`、`store`和`write`这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。
> 如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了 `lock` 和`unlock` 操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令 `monitorenter` 和 `monitorexit` 来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，**因此在 `synchronized`块之间的操作也具备原子性。**

#### 可见性 Visibility

**可见性是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。**

无论是普通变量还是 volatile变量都是如此，他们的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

> **除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。**同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。如代码所示，变量i与j都具备可见性，它们无须同步就能被其他线程正确访问。
>
> 摘自：《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 — 周志明

```java
public static final int i;

public final int j;

static {
    i = 0;
    // 省略后续动作
}

{
    // 也可以选择在构造函数中初始化
    j = 0;
    // 省略后续动作
}
```

#### 有序性 Ordering

有序性简单理解即程序执行的顺序按照代码的先后顺序执行。这里会涉及到指令重排，指令重排可以加快CPU的运行速度，但是在单线程环境中，可以保证最终输出的结果是一致的。在多线程环境中，指令重排就会带来问题，因为其不能保证语句的先后执行顺序，当一个线程的计算任务依赖另一个线程的计算任务的中间结果时，此时就会有问题。

> Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“**线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics）**，后半句是指“**指令重排序”**现象和“**工作内存与主内存同步延迟**”现象。
>
> 摘自：《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 — 周志明

Java语言提供了**volatile**和**synchronized**两个关键字来保证线程之间操作的有序性，**volatile关键字本身就包含了禁止指令重排序的语义**，**而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。**

### 对于volatile型变量的特殊规则

volatile 关键字可以说是 Java 虚拟机提供的**最轻量级的同步机制**， 一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰后，那么就具备了两层语义，即 **volatile 可以保证可见性和顺序性，但不能保证原子性**：

- 保证了一个线程修改了某个变量的值，这个新值对于其他线程来说是**立即可见**的，一个线程对 volatile 变量的读一定能看见在它之前最后一个线程对这个变量的写
  - 这里的**“可见性”**是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以**立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成**
  - 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用**synchronized**、**java.util.concurrent中的锁**或**原子类**）来保证原子性：
    - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
    - 变量不需要与其他的状态变量共同参与不变约束。
- **禁止进行指令重排序**

为了实现这些语义，Java规定：

- 当一个线程要使用共享内存中的 volatile 变量时，它会直接从主内存中读取，而不使用自己本地内存中的副本
- 当一个线程对一个 volatile 变量进行写时，它会将这个共享变量的值刷新到共享内存中。

volatile 在硬件层面使用的是 内存屏障 memory barrier 的机制。

volatile变量**读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。**不过即便如此，大多数场景下volatile的总开销仍然要比锁来得更低。我们在volatile与锁中选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求。

### 针对long和double型变量的特殊规则

> Java内存模型要求lock、unlock、read、load、assign、use、store、write这八种操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将**没有被volatile修饰**的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的**“long和double的非原子性协定**”（**Non-Atomic Treatment of double and long Variables**）。
>
> 摘自：《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》 — 周志明

在实际开发中，除非该数据有明确可知的线程竞争，否则我们在编写代码时一般不需要因为这个原因刻意把用到的long和double变量专门声明为volatile。

## Reference

1. 《深入理解Java虚拟机 第三版》
2. [JSR 133](https://jcp.org/en/jsr/detail?id=133)
