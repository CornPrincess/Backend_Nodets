# Java 垃圾清理

## 如何判读对象已死

### 引用计数法

原来简单，判断效率高，但是不能解决相互循环引用的问题

### 可达性分析算法

通过一系列称为 GC Roots 的根对象作为起始节点集，若对象不可达，则此对象是不可能再被使用的。

GC Roots一般有以下几种：

- 虚拟机栈中引用的对象
- 方法区中静态属性引用的对象，如Java 类的引用类型静态变量
- 在本地方法栈中JNI（Native 方法）引用的对象
- Java 虚拟机内部的引用：基本类型对于的Class对象，一些常驻的异常对象，系统类加载器
- 被同步锁（synchronized）持有的对象
- 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

## 引用类型

### 强引用 Strongly Reference

指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，**只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。**

### 软引用 Soft Reference

只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

等于说是平时不会列入回收名单。只有存在oom风险时，才会进行第二次回收。

### 弱引用 Weak Reference

弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。**

等于说垃圾收集一开始，弱引用就会被回收

### 虚引用 PhantomReference

虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，**也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。**在JDK 1.2版之后提供了PhantomReference类来实现虚引用。

等于是个工具人，只为零在gc时收到一个系统通知

## 生存还是死亡

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：

- 可达性不通过，第一次标记
- 进行筛选：此对象是否有必要执行finalize()方法。
  - 假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。
  - 如果有必要执行 finalize() 方法，那么对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法
- 若在第二步中执行 finalize 方法，此时会对F-Queue中的对象进行**第二次小规模的标记**，如果要在 finalize中救自己，只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在**第二次标记时它将被移出“即将回收”的集合；**

## 回收方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。

首先方法区可能有些虚拟机不会进行垃圾收集，如如JDK 11时期的ZGC收集器就不支持类卸载。

方法区的垃圾收集主要回收两部分内容：**废弃的常量**和**不再使用的类型。**

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

## 垃圾收集算法

垃圾收集算法的实现涉及大量的程序细节，且各个平台的虚拟机操作内存的方法都有差异，在本节中我们暂不过多讨论算法实现，只重点介绍分代收集理论和几种算法思想及其发展过程。如果读者对其中的理论细节感兴趣，推荐阅读RichardJones撰写的《垃圾回收算法手册》[插图]的第2～4章的相关内容。

从**如何判定对象消亡**的角度出发，垃圾收集算法可以划分为**“引用计数式垃圾收集”（Reference Counting GC）**和“**追踪式垃圾收集”（Tracing GC）**两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，

### 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了**“分代收集”（GenerationalCollection）**的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：**收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。**

Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，因此才有了 Minor GC，Major GC， Full GC

目前的流程是： 分代理论-- 依据年龄堆分为多个区域--各种标记算法

把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为**新生代（Young Generation）**和**老年代（Old Generation）**两个区域（Hotspot 的分发）



划分 内存区域存在这样一个问题：**对象不是孤立的，对象之间会存在跨代引用。**

假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样[插图]。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。

为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

**3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。**

### 垃圾收集分类

#### 部分收集（Partial GC）

指目标不是完整收集整个Java堆的垃圾收集，其中又分为：

- 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。

- 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。**目前只有CMS收集器会有单独收集老年代的行为。**另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
- 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有**G1收集器**会有这种行为。

#### 整堆收集 Full GC

收集整个Java堆和方法区的垃圾收集。

### 垃圾收集算法

#### 标记-清除算法

最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，在1960年由Lisp之父John McCarthy所提出。如它的名字一样，算法分为“标记”和“清除”两个阶段

- 首先标记出所有需要回收的对象
- 在标记完成后，统一回收掉所有被标记的对象

主要存在两个缺点：

- 执行效率不稳定，若存在 大量需要清理的对象，此时需要进行大量的标记 和清理
- 容易造成内存空间的碎片化问题，若要分配较大对象时，会 因无法找到足够的连续内存而不得不触发下一次gc

#### 标记-复制算法

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种称为“半区复制”（SemispaceCopying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

简单概述一下思路：

- 将内存分为两块，每次只使用其中一块
- 当在使用的那块内存使用完毕，就把还存活的对象复制到另一块
- 在把已使用过的可回收内存空间一次清理掉

问题：

- 当存活对象较多时，需要复制较多对象
- 可用内存缩减为原来的一半

优点：不用考虑空间碎片问题

现在的商用Java虚拟机大多都**优先采用**了这种收集算法去**回收新生代**

在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。

发生垃圾搜集时，将**Eden**和**Survivor**中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。

任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，**当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。**

缺点：需要担保，存活对象较多时不适用，因此用在新生代

#### 标记-整理算法

针对老年代对象的存亡特征（存活对象多），1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，**但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存**

标记-清除算法与标记-整理算法的**本质差异**在于前者是一种**非移动式**的回收算法，而后者是**移动式**的。**是否移动回收后的存活对象是一项优缺点并存的风险决策：**

缺点：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，**移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行**，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop TheWorld”。

优点：内存连续，吞吐量（用户程序与gc程序）高

> 最新的 ZGC 和 Shenandoah 收集器使用了读屏障技术实现了整理过程和用户线程的并发执行

关注**吞吐量**的**Parallel Scavenge收集器是基于标记-整理算法**的，而关注延迟的**CMS收集器则是基于标记-清除算法**的，这也从侧面印证这点。

