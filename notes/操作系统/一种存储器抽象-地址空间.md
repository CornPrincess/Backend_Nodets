# 一种存储器抽象：地址空间 Address Spaces

总之，将物理地址暴露给进程会带来很多问题：

- 如果一个用户程序可以寻址内存的每个字节，它就可以很容易的破坏操作系统
- 使用这个模型，想要同事运行多个程序是很困难的

## 地址空间的概念（Notion）

**要保证多个应用程同时处于内存中并且不互相影响，需要解决两个问题：保护和重定位（protection and relocation）**。我们可以看到 IBM 360 给内存块标记一个保护键，通过比较执行程序的键和其访问的每个内存字的保护键，然而没有很好地解决重定位的问题。

一个更好的办法是创建一个新的内存抽象：地址空间（the address space）。地址空间为程序创造了一中抽象的内存，地址空间是一个进程可用于寻址内存的一套地址集合（set of addressed）。每个进程都有自己的地址空间，并且这个地址空间独立与其他进程的地址空间（除了在一些特殊情况下进程需要共享他们的地址空间外）。

地址空间的概念很好理解，但是比较难的是给每个程序一个自己的地址空间，是的一个程序中的地址28对应的物理地址与另一个程序中的地址28对应的物理地址不同。

### 基址寄存器与界限寄存器（Base and Limit Registers）

这个简单的解决办法是用一种简单的**动态重定位（dynamic relocation）**，它所做的是简单地把每个进程的地址空间映射到物理内存的不同部分。

所使用的经典办法是，给每个CPU配置两个特殊硬件寄存器（special hardware registers），通常成为基址寄存器（base register）和界限寄存器（limit register），当使用这两个寄存器时，程序装载到内存中连续的空间位置且装载期间无须重定位。

当一个程序运行时，程序的其实物理地址装载到基址寄存器，程序的长度装载到界限寄存器。

**每次一个进程访问内存时，取一条指令，读或者写一个数据字，CPU硬件会在把地址发送到内存总线前自动把基址值加到进程发出的地址值上。同时，它检查程序提供的地址是否等于或大于界限寄存器里的只，如果访问的地址超过了界限，会产生错误并中止访问，**

这种方法的缺点是：每次访问内存都需要进行加法和比较运算。比较可以做得很快，但是加法由于进位传递时间（carry-propagation）的问题，在没有特殊电路的情况下会显得很慢。

## 交换技术 Swapping

