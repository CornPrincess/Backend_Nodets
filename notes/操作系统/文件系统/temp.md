## 文件系统性能 File-System Performance

访问磁盘的速度比访问内存的速度慢很多，因此有几种方法用来改善性能

### 高速缓存 Caching

最常用的减少磁盘访问次数技术是**块高速缓存（block cache）**或者**缓冲区高速缓存（buffer cache）**高速缓存在逻辑上是一系列的块，他们在逻辑上属于磁盘，但实际上基于性能的考虑放在内存中。

管理高速缓存常用的算法为：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无序访问访问磁盘。如果该块不在高速缓存中，则首先把 它读到高速缓存中，再复制到需要的地方。

需要快速判断块是否在高速缓存中，常用的方法为把磁盘地址进行散列操作。

- [ ] 补图

如果高速缓存已满，那么此时就可以用到LRU算法，我们可以在图中看到，双向链表将最近使用的块放在链尾，而最少使用的块放在表头。

现在如果一个关键块读入了缓存并做了修改但是没有写回磁盘。这是，系统崩溃导致文件不一致。把i节点放在链尾，此时需要相当长一段时间走到链头被重写如磁盘，因此要做如下修改：

- 这一块是否不久后会被用到
- 这一块是否关系到文件一致性

因此可以将块分为i节点块，间接块（indirect blocks）、目录块、满数据块和部分数据块。把有可能最近不在需要的块放在链表前部，对很快将会用到的块，如数据块，放在链表尾部。

如果关系到文件系统一致性的该块被修改，应该立即写入磁盘。

**但我们有时不希望数据块在缓存中放太久，比如编辑文档时突然崩溃，此时数据在数据块中，而数据块在高速缓存中，将会丢失工作数据，对于这种情况，UNIX提供了 sync 系统调用，它强制把全部修改过的块立即写回磁盘。系统运行时，后台运行一个通常名为update的程序，它无限循环不断执行sync调用，每次间隔30s。**

**Windows采用一个等价的系统调用，FlushFileBuffers,， 其做法是，只要被写进高速缓存，就把每个被修改的块写进磁盘。将缓存中所有被修改的块立即写回磁盘称为通写高速缓存（write through cache），不过这需要更多的磁盘IO。**

### 块提前读 Block Read Ahead

**在需要用到块之前，试图提前将其写入高速缓存，从而提高命中率。但块提前读策略值适合顺序读取的文件，对随机存取文件，提前读不起作用。**

### 减少磁盘臂运动 Reducing Disk-Arm Motion

将有可能顺序存取的块放在一起，当然是最好在一个柱面（cylinder）上



## 磁盘碎片整理 Defragmenting Disks

在初始安装操作系统后，从磁盘的开始位置，一个接一个地连续安装了程序和文件。所有的空闲磁盘空间放在一个单独的、与被安装的文件临近的单元里。但随着时间的流逝，文件不断地被删除创建，会产生很多碎片，此时新建的文件会散布在磁盘上，造成性能的降低。

磁盘性能可以通过如下方式回复：移动文件使他们相邻，并把所有的（至少大部分）的空闲空间放在一个或多个大的连续的区域内。Windows有一个程序 `defrag` 就是做这个工作的。
