# 页面置换算法 Page ReplaceMent Algorithms

发生缺页中断（page fault）时，操作系统必须从内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果要换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘以更新该页面在磁盘上的副本；如果该页面没有被修改过，那么它在磁盘上的副本已经是最新的（如一个包含程序正文的页面），不需要回写，直接用调入的页面覆盖调淘汰的页面就可以了。

当发生缺页中断时，可以随机选择一个页面来置换，但是如果每次选择不常使用的页面会提示系统的性能，因此存在多种页面置换算法。的那会这些页面置换算法都存在一个问题：当需要从内存中换出某个页面时，它是否只能是缺页进程本身的页面？这个要换出的页面是否可以属于另一个进程？在前一中情况下，可以有效地将每一个进程限制在固定的页面数目中；后一种情况不能，这两种情况都有可能。

## 最优页面置换算法 The Optimal Page Replacement Algorithm

这个算法的思路为：在缺页中断发生时，有些页面在内存中，其中有一个页面将很快被访问，而其他页面可能要到10、100或1000条指令后才会被访问，吗，诶个页面都可以用在该页面首次被访问前所要执行的指令数作标记，最优页面置换算法规定置换标记最大的页面，从而把需要调入这个页面而发生的缺页中断推迟到将来。

这个算法的唯一问题是无法被实现，当缺页中断发生时，操作系统无法知道各个页面下一次访问是什么时候。当然可以通过仿真程序可以实现该算法，从而与其他可行算法进行性能的比较，但最优页面置换算法在实际系统中却不能使用。

## 最近未使用页面置换算法 The Not Recently Used Page Replacement Algorith

操作系统为每一页面设置两个状态位，页面被访问（读或写）设置R位，页面被修改是写入M位，每次访问内存时更新这些位，因此由硬件来设置它们是必要的，一旦设置某位为1，它就一直保持1知道操作系统将他复位。

可以用R位和M位来构造一个简单的页面置换算法：当启动一个进程时，它的所有页面的两个位都由操作系统设置为0，R位被定期地（比如在每次时钟中断时）清理，以区别最近没有被访问的页面和被访问的页面。

当发送缺页中断时，操作系统检查所有的页面并根据他们当前的R位和M位的值，把它们分为四类：

- 第0类：R=0， M=0

- 第1类：R=0， M=1

- 第2类：R=1，M=0

- 第3类：R=1， M=1

清除R位不清除M位是因为在决定一个页面是否要写入磁盘时需要这些信息，也因此产生了第1类..

**NRU(Not Recently Used)算法随机地从类编号最小的非空类中挑选一个页面淘汰。这个算法隐含的意思为:在最近的一个时钟中,淘汰一个没有被访问的已修改的页面要比淘汰一个频繁使用的"干净"的页面好。NRU主要有点是易于理解和能够有效实现，虽然它的性能不是最好的，但已经够用了。**

## 先进先出页面置换算法 The First-In, First-Out (FIFO) Page Replacement Algorith

由操作系统维护一个所有当前在内存中的页面的链表，最新进入的放在表尾，最久进入的页面放在表头。当发送缺页中断时，淘汰表头的页面并把新调入的页面加入到表尾。但这一算可能会淘汰调常用的页面，因此很少使用春岁的FIFO算法。

## 第二次机会页面置换算法 The Second-Chance Page Replacement Algorithm

FIFO算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：**检查最老页面的R位，如果R为是0，那么这个页面既老有没被使用，可以立即置换；如果是1，就将R位清0，并把该页面放到链表尾端，修改它的装入时间使它像刚装入一样。**

![second chance page replace](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/second%20change%20page%20replace.png)

第二次机会算法就是寻找一个最近的时钟间隔以来没有被访问过的页面，如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法，上图中如果所有页面都被访问过，最后清除的还是A，因为所有页面R位都被置零。该算法总是可以结束的。

## 时钟页面置换算法 The Clock Page Replacement Algorithm

第二次机会算法经常要在链表中移动页面，既降低了效率又不是很有必要，一个更好地 办法是将所有的页面都保存在一个类似钟面的环形链表，一个表针指向最老的页面。

当发生缺页中断时，算法首先检查表针所指的页面，如果它的R位为0就淘汰该页面，并将新的页面插入到这个位置，然后表针前移一个位置。如果R为是1就清除R位并把表针前移一个位置，重复这个过程知道找到了一个R位为0的页面位置。

![clock page replacement algorithm](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/clock%20page%20replacement.png)

## 最近最少使用页面置换算法 The Least Recently Used (LRU) Page Replacement Algorith

**对最优算法的很好的近似是基于这样的观察：在前面几条指令中频繁使用的页面很可能在后面几条指令中被使用。反过来说，已经很久没有使用的页面很有可能在未来较长一段时间内任然不会被使用。这个思想提示了一个可实现的算法，在页面中断发生时，置换未使用时间最长的页面，这个策略成为LRU（least recently used）页面置换算法。**

虽然LRU理论上是可行的，但代价很高，为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的放在表头，最近很少使用的页面放在表尾。困难的是在每次访问内存时都必须要更新真个链表，在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作。

有一些特殊的硬件可以实现：

- 64位计数器C，它在每条指令执行完后自动加1，每个页表项有一个容纳这个计数器值的域，每次访问内存后，将当前C值保存到被访问页面的页表项中，发送页面中断时，操作系统检查所有页面项的值，找到值最小的页面，这个页面就是最近最少使用的页面。
- 在一个有n个页框的机器中，LRU硬件可以维护一个初值为0 * 0 的矩阵。访问页框k时，将第k行置1，第k列值0

## 用软件模拟LRU

很少有计算机能支持前面的硬件，因此需要有一个能用软件实现的解决方案。一种可能的方案称为**NFU（Not**

 **Frequentlu Used）算法****。该算法将每个页面与一个软件计数器相关联，计数器的初值为0，每次时钟中断时，有操作系统扫描内存中所有的页面，将每个页面的R位（它的值为0或1）加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发送缺页中断时，则置换计数器值最小的 页面。**

NFU 的主要问题是它从不忘记任何事情，在第一次扫描中被频繁使用的页面在程序进入第二次扫描时，其计数器的值可能任然很高。

只要做两个小改动就可以解决问题：**首先，在R位被加进来之前先将计数器右移一位，其次，将R位加到计数器最左端的位而不是最右端的位。修改之后的算法称为老化（aging）算法。**

![simulate LRU](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/simulates%20LRU.png)

发生缺页中断时，将置换计数器值最小的页面。

LRU和老化算法的区别之一是，老化算法的计数器只有有限位数（本例是8位），这就限制了其对以往页面的记录。如果两个页面的计数器都是0，我们只能在两个页面中随机选一个进行置换。实际上，有可能其中一个页面上次被访问是在9个时钟之前，而另一个是在1000个时钟之前，而我们无法看到这些。在实际中如果时钟滴答（clock tick）是20ms，8位一般是够用的，如果一个页面在160ms中没有被访问过，那么它很可能不重要。

## 工作集页面置换算法 The Working Set Page Replacement Algorithm

在单纯的分页系统里，刚启动进程时，在内存中并没有页面。在CPU试图取第一条指令时就会产生一次缺页中断，使操作系统装入含有第一条指令的页面。其他有访问全局数据和堆栈引起的缺页中断通常会紧接这发生，一段时间以后，进程需要的大部分页面都已经在内存了，进程开始在较少缺页中断的情况下运行，**这个策略称为请求调页（demand paging）因为页面是在需要时被调入的，而不是预先装入。**

大部分进程都表现出一种局部性访问行为（locality of reference），即在进程运行的任何阶段，它都访问较少的的一部分页面。**一个进程当前正在使用的集合称为它的工作机集（working set）**如果整个工作机都被装入内存中，那么进程在运行到下一运行阶段之前，不会产生很多缺页中断。若内存太小无法放入整个工作集，那么进程的运行过程会产生大量的缺页中断，因此运行速度很慢。**若每执行几条指令程序就发送一次缺页中断，那么就称这个程序发送了颠簸（thrashing）**

在多道程序设计系统中，经常会把进程转移到磁盘上（即从内存中一走所有页面），这样可以让其他进程有机会占用CPU。但当该进程再次调回来怎么办，此时工作集不在内存中会产生大量缺页中断，程序运行速度慢不说，还会浪费大量的CPU时间。**因此不少分页系统都会设法跟踪进程的工作集，以确保再让进程运行以前，它的工作集就已经在内存中了，该方法称为工作集模型（working set model）。**其目的是在于大大减少缺页中断**，在让进程运行前预先装入其工作集页面也称为预先调页（prepaging），并注意工作集是随着时间变化的。**

有了工作集模型，可以推导出页面置换算法：**当发送缺页中断时，淘汰一个不在工作集中的页面。为了实现该算法，就需要一种精确的方法来确定哪些页面在工作集中。可以通过移位寄存器来获得最近k次内存访问过的页面的集合，但是这在技术上没有使用过，因为在缺页中断时处理它开销很大。**

作为替代，有几种近似的方法，其中一种就是考虑其执行时间，我们定义的工作集为前1000万次内存访问所使用过的页面的集合，那么现在就可以这样定义，**工作集是过去10ms中的内存访问所用到的页面的集合。一个进程从它开始执行到当前所实际使用的CPU时间总数通常从称作当前实际运行时间（current virtual time）**

具体算法见下图：

![working set](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/working%20set.png)

## 工作集时钟页面置换算法 The WSClock Page Replacement Algorithm

当缺页中断发生时，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的，WSClock算法实现简单，功能较好，所以在实际工作中得到了广泛应用。

与时钟算法一样，所需的数据结构是一种以页框为元素的循环表。最初，该表是空的，当装入第一个页面后，把它加入到该表。随着越来越多的页面加入，他们形成一个环。每个表项包含来自基本工作集算法的上次使用时间，以及R位，M位。

![WSClock](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/WSClock.png)

## 页面置换算法小结

最优算法在当前页面中置换最后要访问的页面，不幸的是没有办法来判断哪个页面是最后一个要访问的，因此实际上该算法不能使用，然而，它可以作为衡量其他算法的基准。

NRU算法根据R位和M位状态把页面分为四类，从编号最小的类中随机选择一个页面置换，该算法易于实现，但是性能不是很好。

FIFO算法通过维护一个页面的链表来记录他们装入内存的顺序，淘汰的是最老的页面，但是该页面可能任然在使用，因此FIFO算法不是一个好选择。

第二次机会算法是对FIFO的改进，它在移除页面前先检查该页面是否正在被使用，这提示了性能。

时钟算法是第二次机会算法的另一种实现，它具有相同的性能特征，而且只需要更少的执行时间。

LRU算法是很优秀的算法，它替换最近最少使用的页面，但是只能通过硬件实现。

NFU是一直接近LRU的算法，它的性能不是很好。

老化算法是对NFU算法的改进，更近似于LRU并可以更有效地实现。

工作集算法有合理的性能，但它的实现开销较大

工作集时钟算法是一种变体，不仅具有良好的性能，并且还能高效的实现。

总之，最好的两种算法是老化算法和工作集时钟算法，他们分别基于LRU和工作集，他们都具有良好的页面调度性能，可以有效地实现。

| **Algorithm**              | **Comment**                                    |
| -------------------------- | ---------------------------------------------- |
| Optimal                    | Not implementable, but useful as a benchmark   |
| NRU (Not Recently Used)    | Very crude approximation of LRU                |
| FIFO (First-In, First-Out) | Might throw out important pages                |
| Second chance              | Big improvement over FIFO                      |
| Clock                      | Realistic                                      |
| LRU (Least Recently Used)  | Excellent, but difficult to implement exactly  |
| NFU (Not Frequently Used)  | Fairly crude approximation to LRU              |
| Aging                      | Efficient algorithm that approximates LRU well |
| Working set                | Somewhat expensive to implement                |
| WSClock                    | Good efficient algorithm                       |

