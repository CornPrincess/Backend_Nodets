 # 死锁预防

从前面的学习我们可以知道，死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。实际的系统从产生死锁的四个必要条件入手。

## 破坏互斥条件 Attacking the Mutual-Exclusion Condition

考虑破坏互斥条件，即资源不被一个进程独占，那么死锁肯定不会产生。通过采用假脱机打印机（spooling printer）技术可以允许若干个进程同事产生输出。该模型中唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程（daemon）不会请求别的资源，所以不会因打印机而产生死锁。

一般将守护进程设计成在完整的输出文件就绪后才开始打印。

这里的小思路可以适用：避免分配哪些不是绝对必须的资源，尽量做到尽可能少的进程可以真正请求资源（例如使用daemon）

## 破坏占有和等待条件 Attacking the Hold-and-Wait Condition

这种方法可以通过**禁止已持有资源的进程再等待其他资源便可以消除死锁。**

**一种实现方法是规定所有进程在开始执行前请求所需的全部资源，**如果全部资源可以，那么分配给这个进程，于是该进程可定能运行结束。如果一个或多个资源正在被使用，就不进行分配，进程等待。

**这种方法的问题是很多进程直到运行时才知道它需要多少资源。实际上，如果进程能够知道它需要多少资源，就可以使用银行家算法。另一个问题是这种方法在资源利用率上不是最优**

另一种方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源。

## 破坏不可抢占条件 Attacking the No-Preemption Condition

一些资源可以通过虚拟化的方法，如假脱机，但不是所有资源都可以进行类似的虚拟化。例如，数据库中的记录或者操作系统中的表都必须被锁定。

## 破坏环路等待条件 Attacking the Circular Wait Condition

一种方法是保证每个进程在任何时刻只能占用一个资源，入股请求另一个资源，它必须先释放第一资源。但这种方法有时是不能接收的，如一个进程正在把文件从磁盘读入并送到打印机打印。

另一种方法是给所有资源统一编号，进程可以在任何时刻提出资源请求，但是所有请求必须安装资源编号的顺序（升序）提出。一个变种是放弃按升序请求资源的限制，而仅仅要求不允许进去请求比当前占用资源编号低的资源。

尽管资源编号的方法消除了死锁的问题，但几乎找不到一种使每个人都满意的编号次序。

