# 其他问题

## 两阶段锁 Two-Phase Locking

在数据库系统中，经常发生的操作就是请求锁住一些记录，然后更新所有锁住的记录。当同时有多个进程运行时，就会出现死锁的现象。

常用的方法是两阶段锁，在第一阶段，进程试图对所需的记录进行加锁，一次锁一个记录。如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。在第一阶段并没有做实际的工作。

如果在第一阶段某个进程需要的记录已经被加锁，那么该进程释放它所有加锁的记录，然后重新开始第一阶段。从某种意义上说，这种方法类似提前或者至少是未实施一些不可逆的操作之前请求所有资源。在一些版本中，如果第一阶段遇到了已加锁的记录，并不会释放锁然后重新开始，这可能会产生死锁。

不过，一般意义下，这种策略并不通用，如果一个进程已经在网络上读写消息，更新文件或者从事任何不能安全地重复做的事，那么重新运行进行也是不可接收的。

## 通信死锁 Communication Deadlocks

```c
typedef int semaphore;
semaphore resource 1; 
semaphore resource 2; 

void process A(void) {
    down(&resource 1); 
    down(&resource 2); 
    use both resources( );
    up(&resource 2); 
    up(&resource 1); 
} 

void process B(void) { 
    down(&resource 2); 
    down(&resource 1); 
    use both resources( ); 
    up(&resource 1); 
    up(&resource 2); 
}
```

在这个例子中，我们可以看到，每个进程都成功调用一个资源（互斥锁之一）
