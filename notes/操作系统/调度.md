# 调度

当计算机系统是多道程序设计（multiprogrammed）系统，通常就会有多个进程或线程同时竞争CPU。只要有两个或更多的进程处于就绪状态，这种情形就可能发生。如果只有一个CPU可用，那么必须选择下一个允许的进程。在操作系统中，完成选择工作的这一部分称为调度程序（scheduler），该程序使用的算法称为 调度算法（scheduling algorithm）

许多适用于进程调度的处理方法也同样适用于线程调度。**当内核管理线程的时候，调度经常是按照线程级别的，与线程所属的进程基本或根本没有关联。**

## 调度简介

在批处理系统时代，CPU是稀缺资源 ，大量的研究工作都花费在创造聪明而有效的调度算法上了。

在个人计算机出现之后，整个情形向两个方面发展。首先，在多数时间内只有一个互动进程，其次。下那种计算机速度极快，计算机的多数程序受到的是用户当前输入（键入或敲击鼠标）速率的限制，而不是CPU处理效率的限制。

对于网络服务器，多个进程经常竞争CPU，因此调度功能再一次变得至关重要。

另外，为了选娶正确的进程允许，调度程序还要考虑CPU的利用率，因为进程切换的代价是比较高的：

- 首先用户态必须切换到内核态
- 然后保存当前进程的状态，包括在进程表中存储寄存器值以便以后重新加载，在许多系统中，内存映像（memory map）也必须保存
- 通过允许调度算法选定一个新进程
- 将新进程的内存映像重新装入MMU（memory management unit内存管理单元）
- 新进程开始运行

初次之外进程切换还需要将整个内存告诉缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次，离开内核一次）

### 进程行为

几乎所有进程的（磁盘或网络）I/O请求和计算都是交替突发的。典型地，CPU不停顿的运行一段时间，然后发出一个系统调用一遍读写文件。在完成系统调用之后，CPU又开始计算。

按照这种观点，当一个进程等待外部设备完成工作而被阻塞时，才是I/O活动。

![CPU Usage](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/CPUUsage.png)

> The former are called **compute-bound** or **CPU-bound**; the latter are called **I/O- bound**. Compute-bound processes typically have long CPU bursts and thus infre- quent I/O waits, whereas I/O-bound processes have short CPU bursts and thus fre- quent I/O waits. Note that the key factor is the length of the CPU burst, not the length of the I/O burst. I/O-bound processes are I/O bound because they do not compute much between I/O requests, not because they have especially long I/O re- quests. It takes the same time to issue the hardware request to read a disk block no matter how much or how little time it takes to process the data after they arrive.

有必要指出，随着CPU变得越来越快，更多的进程倾向为I/O密集型 （I/O-bound），这种现象 之所以发生时因为CPU的改进比磁盘的改进快得多，其结果是，未来对I/O密集型进程的调度处理似乎更为重要。

### 何时调度

存在这需要调度处理的各种情形：

- 创建一个新进程之后，需要决定是运行父进程还是运行子进程，由于两种进程都处于就绪状态，所以这是一个正常的调度决策，可以任意决定。
- 在一个进程退出时必须做出调度决策，从就绪进程集中选择进程，如果没有就绪就绪的进程，通常会运行一个系统提供的空闲进程（system-supplied idle process）。
- 当一个进程阻塞在IO或信号量（semaphore）上时，必须选择另一个进程运行
- IO中断（interrupt）发生时，必须做出调度决策。If the interrupt came from an I/O device that has now completed its work, some process that was blocked waiting for the I/O may now be ready to run. It is up to the scheduler to decide whether to run the newly ready process, the process that was running at the time of the interrupt, or some third process.

根据如何处理时钟中断（clock interrupts），可以将调度算法分成两类：**非抢占式（nonpreemptive）调度算法和抢占式（preemptive）调度算法**

**非抢占式：**

- 挑选一个进程，然后让该进程运行直至被阻塞（阻塞在IO或者等待另一个进程），或者知道该进程自动释放CPU，及时该进程运行了若干小时也不会被强迫挂起。

- 在时钟中中断发生时不会进行调度，在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行

**抢占式：**

 - 挑选一个进程，并且让该进程运行某个固定时段的最大值，如果该时间段结束，进程仍在运行，则它就被挂起，而调度程序挑选另一个进程运行
 - 进行抢占式调度，需要在时间间隔的末端发送时钟中断，以便把CPU控制返回给调度程序，如果没有可用的时钟，那么非抢占式调度就是唯一的选择了。

### 调度算法的分类

在不同的系统中，调度程序的优化是不同的，可以划分为三种环境：

- 批处理 Batch
- 交互式 Interactive
- 实时 Real time

批处理系统在商业领域仍在广泛引用，在批处理系统中，不会有客户不耐烦的等待短请求的响应，因此非抢占式算法或者对每个进程都有长时间周期的抢占式算法，通常是可以接收的。

在交互式用户环境中，为了避免一个进程霸占CPU拒绝为其他进程服务，抢占是必须的，服务器也算在这类。

在实时限制的细节图中，抢占有时是不需要的。

### 调度算法的目标

## 批处理系统中的调度

### 先来先服务 First-Come,First-Served

先来先服务是最简单的非抢占式算法，进程按照他们请求CPU的顺序使用CPU，**有一个就绪进程的单一队列**。当第一个进程从外部进入系统，就立即开始并允许允许它所期望的时间，不会中断该作业。当其他作业进入时，就会被安排到队列尾部。当正在允许的进程阻塞时，队列 第一个进程接着运行，在被阻塞的进程变为就绪时，就像一个新来到的作业，排到队列的末尾。

在这个算法中，一个单链表记录了所有就绪进程，要选取一个进程运行，只要从该队列的头部一走一个进程即可，要添加一个新的作业或阻塞一个进程，只要把该作业或进程附加在相应的队列的末尾即可

### 最短作业优先 Shortest Job First

现在来看适用于运行时间可以预支的另一个非抢占式的批处理调度算法，当输入队列中有若干同等重要的作业要被启动时，调度程序应该使用最短作业优先，即将短作业放在队列的前面。

只有在所有的作业都可以同时运行的情形下，最短作业优先算法才是最优化的。

### 最短剩余时间优先 Shortest Remaining Time Next

最短作业优先的抢占式版本是最短剩余时间优先算法。**使用这个算法，调度程序总是选中剩余运行时间最短的那个进程运行。有关的运行时间必须提前掌握。**



##  交互式系统中的调度

### 轮转调度 Round-Robin Scheduling

每个进程被分配一个时间段，称为时间片（quantum），即允许该进程在该时间段中运行，如果在时间片结束时该进程还在运行，则剥夺CPU并分配给另一个进程，如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换

时间片轮转调度唯一有趣的一点是时间片的长度，从一个进程切换到另一个进程需要一定时间进行管理事务处理——保存和装入寄存器值（registers）和内存映像（memory map），更新各种表格和列表，清除和重新调入内存高速缓存等。假如进行进程切换（process switch），有时成为上下文切换（context switch）需要1ms，时间片设为4ms，则CPU在完成4ms有用的工作之后，将浪费1ms进行进程切换，即CPU花费20%的时间在管理的开销上

结论：时间片设置太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设置为2ms-50ms通常是一个比较合理的折中（reasonable compromise.）。

![round-robin scheduling](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/round-robin.png)

### 优先级调度 Priority Scheduling

轮转调度做了一个 隐含的假设，即所有的进程同等重要，我们这里考虑优先级调度，**基本思想是每一个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。**

为了防止最高优先级进行无休止运行下去，调度程序可以在每个时钟中断降低当前进程的优先级。每个进行可以别赋予可以运行的最大时间片（quantum），当这个时间片用完后，下个此高优先级的进程获得机会运行。优先级可以静态赋予或动态赋予，为达某种目的，优先级也可由系统动态确定，是I/O密集型进程获得较好服务的一种简单算法是，将其优先级设为1/f，f为该进程在上一段时间片所占部分，如在一个50ms时间片值使用1ms的进程将获得优先级50，使用25ms的进程获得优先级2，思想就是赶快让CPU计算部分运行，好赶快开始下一次IO操作。

![priority scheduling](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/priority%20scheduling.png)

可以很方便地将一组进程按游戏奶分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。如图，只要存在优先级为4的进程，就安装轮转法给每个进程运行一个时间片，此时不理会较低优先级进程，若第4类进程为空，则按轮转法运行第3类进程，以此类推。如果不偶尔对优先级进行调整，则低优先级进程很可能会产生饥饿现象。

### 多级队列 Multiple Queues

设立优先级列。属于最高优先级的进程运行一个时间片，属于此高优先级类的进程运行2个时间片，再次一级的运行4个时间片，以此类推，当一个进程用完分配的时间片后，它被移到下一类。

### 最短进程优先 Shortest Process Next

我们首先运行最短的作业来是响应时间最短，**这里唯一的问题是如何从当前可运行的进程中找出最短的那一个进程**

一种办法是根据坚持过去的行为进行推测，并执行估计运行时间最短的一个。通过当前测量值和先前估计值进行加权平均而得到的下一个估计值的技术称作**老化（aging）**

### 保证调度 Guaranteed Scheduling

一种完全不同的调度算法是向用户做出明确的性能保证，如用户工作是有n个用户登录，则用户将获得CPU处理能力的1/n。类似的，在一个有n个进程运行的单用户系统中，若所有进程是等价的，则每个进程将获得1/n的CPU时间。

### 彩票制度 Lottery Scheduling

彩票制度的基本思想是向进程提供各种系统资源（如CPU时间）的彩票，一旦需要做出意向调度决策时，就随机抽出一张彩票，拥有彩票的进程获得该资源。当然也可以给更重要的进程额外的彩票。

### 公平分享调度 Fair-Sharing Scheduling

目前为止，假设的调度的是进程自身，而并不关注所有者是谁，这样做的结果是，如果用户1启动9个进程，用户2启动1个进程，那么用户1有90%的CPU时间，用户2只有10%CPU时间，为了避免这样的事情发生，某些系统在调度处理之前考虑谁拥有进程这一因素。在这种模式中，每个用户分配CPU时间的一部分，而调度程序以一种强制的方式选中进程。

## 实时系统中的调度系统

实时系统是一种时间起主导作用的系统，如CD播放器，病人监护装置，飞机自动驾驶系统等。在一些例子中，正确但是迟到的应答往往比没有还要糟糕。

## 策略与机制 Policy Versus Mechanism

将调度机制（Scheduling mechanism） 与调度策略（Scheduling policy）分离，也就是将调度算法以某种形式参数化，而参数可以有用户进程填写。

假设内核使用优先级调度算法，但提供一条可供进程设置优先级的系统调用。这样，尽管父进程本身不参与调度，但它可以控制如何调度子进程的细节。**在这里，调度机制位于内核，调度策略则由用户进程决定。**



## 线程调度

**用户级线程和内核级线程的主要区别在于性能，用户级线程的线程切换需要少量的机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使告诉缓存失效，这导致若干数量级的延迟。另方面，在使用内核级线程时，一旦线程阻塞在I/O上就不需要想在用户线程中那样将整个进程挂起。**

