# 调度

当计算机系统是多道程序设计（multiprogrammed）系统，通常就会有多个进程或线程同时竞争CPU。只要有两个或更多的进程处于就绪状态，这种情形就可能发生。如果只有一个CPU可用，那么必须选择下一个允许的进程。在操作系统中，完成选择工作的这一部分称为调度程序（scheduler），该程序使用的算法称为 调度算法（scheduling algorithm）

许多适用于进程调度的处理方法也同样适用于线程调度。**当内核管理线程的时候，调度经常是按照线程级别的，与线程所属的进程基本或根本没有关联。**

## 调度简介

在批处理系统时代，CPU是稀缺资源 ，大量的研究工作都花费在创造聪明而有效的调度算法上了。

在个人计算机出现之后，整个情形向两个方面发展。首先，在多数时间内只有一个互动进程，其次。下那种计算机速度极快，计算机的多数程序受到的是用户当前输入（键入或敲击鼠标）速率的限制，而不是CPU处理效率的限制。

对于网络服务器，多个进程经常竞争CPU，因此调度功能再一次变得至关重要。

另外，为了选娶正确的进程允许，调度程序还要考虑CPU的利用率，因为进程切换的代价是比较高的：

- 首先用户态必须切换到内核态
- 然后保存当前进程的状态，包括在进程表中存储寄存器值以便以后重新加载，在许多系统中，内存映像（memory map）也必须保存
- 通过允许调度算法选定一个新进程
- 将新进程的内存映像重新装入MMU（memory management unit内存管理单元）
- 新进程开始运行

初次之外进程切换还需要将整个内存告诉缓存失效，强迫缓存从内存中动态重新装入两次（进入内核一次，离开内核一次）

### 进程行为

几乎所有进程的（磁盘或网络）I/O请求和计算都是交替突发的。典型地，CPU不停顿的运行一段时间，然后发出一个系统调用一遍读写文件。在完成系统调用之后，CPU又开始计算。

按照这种观点，当一个进程等待外部设备完成工作而被阻塞时，才是I/O活动。

![CPU Usage](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/CPUUsage.png)

> The former are called **compute-bound** or **CPU-bound**; the latter are called **I/O- bound**. Compute-bound processes typically have long CPU bursts and thus infre- quent I/O waits, whereas I/O-bound processes have short CPU bursts and thus fre- quent I/O waits. Note that the key factor is the length of the CPU burst, not the length of the I/O burst. I/O-bound processes are I/O bound because they do not compute much between I/O requests, not because they have especially long I/O re- quests. It takes the same time to issue the hardware request to read a disk block no matter how much or how little time it takes to process the data after they arrive.

有必要指出，随着CPU变得越来越快，更多的进程倾向为I/O密集型 （I/O-bound），这种现象 之所以发生时因为CPU的改进比磁盘的改进快得多，其结果是，未来对I/O密集型进程的调度处理似乎更为重要。

