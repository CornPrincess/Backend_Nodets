# 进程间通信

进程经常需要与其他进程通信。例如，在一个shell管道中，第一个进程的输出必须传送给第二个进程，这样沿着管道传递下去。因此在进程之间需要通信，而且最好使用一种结构良好的方式，不要使用中断，接下来讨论进程间通信（InterProcess Communication IPC）问题

有三个问题：

- 一个进程的信息如何传递个另一个进程
- 确保两个或更多的进程在关键活动中不会交叉
- 存在依赖时如何保证顺序

其中第一第三个问题同样适用于线程

## 竞争条件 Race Conditions

在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共区域，因此就会存在一些问题

>  Situations like this, where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, are called race conditions.

竞争条件（Race condition）：**两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，成为竞争条件。**

## 临界区 Critical Regions

怎样避免竞争条件，实际上，凡是设计共享内存，共享文件以及共享任何资源的情况都会引发与前面类似的错误，**要避免这种错误，关键是要找出某种途径来组织多个进程同时读写共享的数据，换言之，我们需要的是互斥（mutual exclusion）。**为实现互斥而选择适当的**原语（primitive operation）**是任何操作系统的主要设计内容之一。

我们把对共享内存进行访问的程序片段成为**临界区域（critical region）或临界区（critial section）**。如果我们能够适当安排，**使得两个进程不可能同事处于临界区，就能够避免竞争条件。**

![critical region](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/critical%20region.png)

尽管这样的要求避免了竞争条件，但是它还不能保证使用共享数据的并发进程能够正确和高效地进行协作，对于一个好的解决方案，应该满足：

- 任何两个进程不能同时处于其临界区
- 不应对CPU的速度和数量做出任何假设
- 临界区外运行的进程不得阻塞其他进程
- 不得是进程无限期等待进入临界区

## 忙等待的互斥 Mutual Exclusion with Busy Waiting

本节讨论几种实现互斥的方案，在这些方案中，当一个进程在临界区更新内存时，其他进程将不会进入其临界区。

### 屏蔽中断

在单处理器系统中，最简单的方法是将每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前在打开中断。屏蔽中断后，时钟中断也被屏蔽。**CPU只有在发送时钟中断或者其他中断时才会进行进程切换**。这样，在屏蔽中断后CPU将不会被切换到其他进程，**但是如果有多个处理器，则屏蔽中断仅仅对执行disable指令的那个CPU有效。**

## 锁变量 Lock Variables

作为第二种尝试，可以寻求软件的解决方法，设想有一个共享的锁变量（single shared lock variable），初始为0，当一个进程想要进入临界区时，它首先测试这把锁，如果值为0，则将其置为1并且进入临界区。如果为锁1，则一直等待直到为0.

**但是这种设计同样存在问题（fatal flow），假设一个进程检查当前锁变量为0，在它要置为1之前，另一个进程被调度运行，将该锁变量置为1并进入临界区，随后第一个进程也将其置为1并进入临界区，此时临界区便有两个进程。**

## 严格轮换法 Strict Alternation

![busy waiting](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/operating%20system/busywaiting.png)

我们来看上述第三种互斥的方法，整形变量turn，初始值为0，用来记录轮到哪个线程进入道临界区，并检查或更新共享内存。

- 开始时，进程0检查turn，发现其值为0，于是进入临界区。进程1也发现其值为0，所以在一个等待的循环中不停测试turn（即 while(turn != 1); 这一行代码）看其值何时变为1.

  > Continuously testing a variable until some value appears is called **busy waiting**.It should usually be avoided, since it wastes CPU time. Only when there is a reasonable expectation that the wait will be short is busy waiting used. A lock that uses busy waiting is called a **spin lock**.
  >
  > **连续测试一个变量直到某个值出现为止，成为忙等待（busy waiting）。**由于这种方式浪费CPU时间，所以通常应该避免。只有有理由认为等待时间时非常短的情况下，才使用忙等待。**用于忙等待的锁称为自旋锁（spin lock）。**

- 进程0离开临界区时，它将 turn 值设置为1，以便允许进程1进入其临界区

- 假设进程1很快便离开了临界区，则此时两个进程都处于临界区之外，turn的值又被置为0

- 现在进程0很快就执行完其整个循环，它退出临界区，并将turn置为1，现在两个进程都在其临界区外执行。

- **突然线程0结束了非临界区的操作并且返回到循环的开始，但是它不能进入临界区，因为此时turn=1，而此时及昵称1还在忙于非临界区的操作，进程0只有继续while循环(while(turn != 0);)，直到进程1把turn的值改为0，这说明，在一个进程比另一个慢很多的情况下，轮流进入临界区不是一个好办法。**

上面的情况违反了前面叙述的条件3：**进程0被一个临界区之外的进程阻塞。**

**实际上改方案要求两个进程严格地轮流进入他们的临界区，如假脱机文件等。任何一个进程都不能在一轮中打印两个文件。尽管该算法的确避免了所有的竞争条件，但由于它违反了条件3，所以不能作为一个很好的备选方案。**

### Peterson 解法

> By combining the idea of taking turns with the idea of lock variables and warn- ing variables, a Dutch mathematician, T. Dekker, was the first one to devise a soft- ware solution to the mutual exclusion problem that does not require strict alterna- tion

### TSL 指令

现在来看需要硬件支持的方案。某些计算机中，特别是那些设计为多处理器的计算机，都有下面一条指令： 

> TSL TX,LOCK

称为测试并加锁（test and set lock），它将一个内存字lock读到寄存器RX中，然后在该内存地址上存一个非零值，读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。**执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。**

> It is important to note that locking the memory bus is very different from dis- abling interrupts. Disabling interrupts then performing a read on a memory word followed by a write does not prevent a second processor on the bus from accessing the word between the read and the write. In fact, disabling interrupts on processor 1 has no effect at all on processor 2. The only way to keep processor 2 out of the memory until processor 1 is finished is to lock the bus, which requires a special hardware facility (basically, a bus line asserting that the bus is locked and not avail- able to processors other than the one that locked it).

锁住存储总线不同于屏蔽中断。屏蔽中断，然后在读内存字之后跟着写操作并不能阻止总线上的第二个处理器在读操作和写操作之间访问该内存字。事实上，在处理器1上屏蔽中断对处理器2根本没有任何影响，让处理器2远离内存直到处理器1完成的唯一方法就是锁住总线，这需要一个特殊的硬件设施（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用）

> An alternative instruction to TSL is XCHG, which exchanges the contents of two locations atomically, for example, a register and a memory word. The code is shown in Fig. 2-26, and, as can be seen, is essentially the same as the solution with TSL. All Intel x86 CPUs use XCHG instruction for low-level synchronization.

一个可替代TSL的指令是XCHG



## 睡眠与唤醒

Peterson解法和TSL或XCHG解法都是正确的，但他们都有忙等待（busy waiting）的缺点。**这些解法的本质是这样的：当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，知道允许为止。**

**这种方法不仅浪费了CPU时间，而且还可能引起预想不到的结果。考虑一台计算机有两个进程，H优先级较高，L优先级较低。调度规则规定，只要H处于就绪态，它就可以运行。在某一时刻，L处于临界区中，此时H变到就绪态，准备运行（例如，一条IO操作）。现在H开始忙等待（在就绪态中进行忙等待），但是H就绪时L不会被调度，也就无法离开临界区，所以H将永远忙等待下去。这种情况又是被称作*优先级反转问题（priority inversion problem）。***

现在来考虑几条进程间通信原语（primitive），当进程不能进入临界区时，这些原语用来阻塞进程，而不是纯浪费时间地忙等待。

### 生产者消费者问题 The  Producer-Consumer Problem

我们考虑生产者消费者问题，也叫有界缓冲区(bounded-buffer)问题。两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息。

问题在于当缓区已满，而此时生产者还想向其中放入一个新的数据项的情况，其解决办法是让生产者睡眠，带消费者从缓冲区中取出一个活多个数据项时再唤醒它。同样的，当消费者试图从换从区中去数据而发现缓冲区为空时，消费者就睡眠，知道生产者向其中放入一些数据时再将其唤醒。

```c
#define N 100 
int count = 0;
void producer(void) {
  int item;
  while (TRUE) {
    item = produce
    inser t item(item);
    count = count + 1;
    if (count == 1) wakeup(consumer);
  } 
}
void consumer(void) {
  int item;
  while (TRUE) {
    if (count == 0) sleep( );
    item = remove item( );
    count = count − 1;
    if (count == N − 1) wakeup(producer); consumeitem(item);
  } 
}
```



这里有可能出现竞争条件，其原因是对count的访问为加限制。有可能出现以下情况：

- 缓冲区为空，消费者刚刚读取count的值发现它为0，此时调度程序决定暂停消费者并启动运行生产者。
- 生产者向缓冲区中加入一个数据项，count变为1，此时生产者调用wake up来唤醒消费者
- **但是，消费者此时逻辑上并未睡眠，所以wakeup信号消失。当消费者消磁运行时，它将测试先前读到的coutn值，发现它为0，于是睡眠。**
- **生产者迟早会填满整个缓冲区，然后睡眠，这样两个进程都将永远睡眠下去。**

问题的实质（essence）在于发给一个尚未睡眠的wakeup信号丢失了。如果它没有丢失，则一切都很正常。一中飘过你快速弥补方法是修改规则，加上一个睡眠等待位（wakeup waiting bit），唤醒等待位实际上就是wakeup信号的一个小仓库。但原则上讲（in principle），并没有解决问题。

## 信号量 Semaphores

> This was the situation in 1965, when E. W. Dijkstra (1965) suggested using an integer variable to count the number of wakeups saved for future use. In his pro- posal, a new variable type, which he called a **semaphore**, was introduced. A sem- aphore could have the value 0, indicating that no wakeups were saved, or some positive value if one or more wakeups were pending.

Dijkstra 建议设立两种操作：down 和 up（分别为一般化后的sleep和wakeup）

> The down operation on a semaphore checks to see if the value is greater than 0. If so, it decrements the value (i.e., uses up one stored wakeup) and just continues. If the value is 0, the process is put to sleep without completing the down for the moment. 

> The down oper- ation on a semaphore checks to see if the value is greater than 0. If so, it decre- ments the value (i.e., uses up one stored wakeup) and just continues. If the value is 0, the process is put to sleep without completing the down for the moment. 

> Check- ing the value, changing it, and possibly going to sleep, are all done as a single, indivisible **atomic action**. It is guaranteed that once a semaphore operation has started, no other process can access the semaphore until the operation has com- pleted or blocked. This atomicity is absolutely essential to solving synchronization problems and avoiding race conditions. **Atomic actions, in which a group of related operations are either all performed without interruption or not performed at all, are extremely important in many other areas of computer science as well.**
>
> 检查数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作。保证一旦一个信号量操作开始，则在该搞作完成或阻塞之前，其他进程均不允许访问该信号量。这种原子性对解决同步问题和避免竞争条件是绝对必要的。**所谓原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。原子操作在计算机科学的其他领域也是非常重要的。**

> Semaphores that are initialized to 1 and used by two or more processes to ensure that only one of them can enter its **critical region** at the same time are called **binary semaphores**(二元信号量). **If each process does a down just before entering its critical region and an up just after leaving it, mutual exclusion is guaranteed.**

## 信号量 Mutexes

> When the semaphore’s ability to count is not needed, a simplified version of the semaphore, called a mutex, is sometimes used. Mutexes are good only for man- aging mutual exclusion to some shared resource or piece of code. They are easy and efficient to implement, which makes them especially useful in thread packages that are implemented entirely in user space.
>
> 如果不需要信号量的计数能力，又是可以使用信号量的一个简化版本，**互斥量（mutex），互斥量仅仅适用于管理共享资源或一小段代码。**

> A **mutex** is a shared variable that can be in one of two states: unlocked or locked. Consequently, only 1 bit is required to represent it, but in practice an inte- ger often is used, with 0 meaning unlocked and all other values meaning locked.
>
> 互斥量是一个处于两态之间的变量：解锁和加锁（unlocked or locked）。这样只要一个比特位就可以表示它，但是实际上常常使用一个整形量，0表示解锁，其他的表示加锁。

> Two procedures are used with mutexes. When a thread (or process) needs access to a critical region, it calls *mutex lock*. If the mutex is currently unlocked (mean- ing that the critical region is available), the call succeeds and the calling thread is free to enter the critical region
>
> 互斥使用两个过程。当一个线程（或进程）需要访问临界区时，它调用 `mutex_lock`， 如果互斥量是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。

> On the other hand, if the mutex is already locked, the calling thread is blocked until the thread in the critical region is finished and calls *mutex unlock*. If multi- ple threads are blocked on the mutex, one of them is chosen at random and allowed to acquire the lock.
>
> 另一方面，如果该互斥量已经加锁，调用线程被阻塞，知道在临界区中的线程完成并调用 `mutex_lock` 。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。  