# 进程间通信

进程经常需要与其他进程通信。例如，在一个shell管道中，第一个进程的输出必须传送给第二个进程，这样沿着管道传递下去。因此在进程之间需要通信，而且最好使用一种结构良好的方式，不要使用中断，接下来讨论进程间通信（InterProcess Communication IPC）问题

有三个问题：

- 一个进程的信息如何传递个另一个进程
- 确保两个或更多的进程在关键活动中不会交叉
- 存在依赖时如何保证顺序

其中第一第三个问题同样适用于线程

## 竞争条件 Race Conditions

在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共区域，因此就会存在一些问题

>  Situations like this, where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, are called race conditions.

竞争条件（Race condition）：**两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，成为竞争条件。**

## 临界区 Critical Regions

怎样避免竞争条件，实际上，凡是设计共享内存，共享文件以及共享任何资源的情况都会引发与前面类似的错误，**要避免这种错误，关键是要找出某种途径来组织多个进程同时读写共享的数据，换言之，我们需要的是互斥（mutual exclusion）。**为实现互斥而选择适当的**原语（primitive operation）**是任何操作系统的主要设计内容之一。

我们把对共享内存进行访问的程序片段成为**临界区域（critical region）或临界区（critial section）**。如果我们能够适当安排，**使得两个进程不可能同事处于临界区，就能够避免竞争条件。**

尽管这样的要求避免了竞争条件，但是它还不能保证使用共享数据的并发进程能够正确和高效地进行协作，对于一个好的解决方案，应该满足：

- 任何两个进程不能同时处于其临界区
- 不应对CPU的速度和数量做出任何假设
- 临界区外运行的进程不得阻塞其他进程
- 不得是进程无限期等待进入临界区

## 忙等待的互斥 Mutual Exclusion with Busy Waiting

本节讨论几种实现互斥的方案，在这些方案中，当一个进程在临界区更新内存时，其他进程将不会进入其临界区。

### 屏蔽中断

在单处理器系统中，最简单的方法是将每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前在打开中断。屏蔽中断后，时钟中断也被屏蔽。**CPU只有在发送时钟中断或者其他中断时才会进行进程切换**。这样，在屏蔽中断后CPU将不会被切换到其他进程，**但是如果有多个处理器，则屏蔽中断仅仅对执行disable指令的那个CPU有效。**

## 锁变量 Lock Variables

作为第二种尝试，可以寻求软件的解决方法，设想有一个共享的锁变量（single shared lock variable），初始为0，当一个进程想要进入临界区时，它首先测试这把锁，如果值为0，则将其置为1并且进入临界区。如果为锁1，则一直等待直到为0.

**但是这种设计同样存在问题（fatal flow），假设一个进程检查当前锁变量为0，在它要置为1之前，另一个进程被调度运行，将该锁变量置为1并进入临界区，随后第一个进程也将其置为1并进入临界区，此时临界区便有两个进程。**

## 严格轮换法 Strict Alternation

