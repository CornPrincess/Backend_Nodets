# 查找

## 符号表 Symbol Tables

**Symbol table.**  The primary purpose of a *symbol table* is to associate a *value* with a *key*. The client can *insert* key–value pairs into the symbol table with the expectation of later being able to *search* for the value associated with a given key.

> **Definition.** A*symboltable*isadatastructureforkey-valuepairsthatsupportstwo operations: *insert* (put) a new pair into the table and *search* for (get) the value as- sociated with a given key.

符号表最主要的目的是将一个键和一个值联系起来，不光可以进行高效地**插入和查找**，还能进行其他的操作.典型符号表的应用

![symbol table application](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/symbolTableApplication.png)

### API

![symbol table API](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/STAPI.png)

**具体实现的注意点**：见 Reference

### 有序符号表 Ordered Symbol Tables

> In typical applications, keys are `Comparable` objects, so the option exists of using the code `a.compareTo(b)` to compare two keys `a` and `b`. Several symbol-table implementations take advantage of order among the keys that is implied by `Comparable` to provide efficient implementations of the `put()` and `get()` operations. More important, in such implementations, we can think of the symbol table as keeping the keys in order and consider a significantly expanded API that defines numerous natural and useful operations involving relative key order. For applications where keys are `Comparable`, we implement the following API:

- [ ] 补图

**API注意点**：见 Reference

**查找成本模型**：在学习符号表的实现时，我们会统计**比较的次数**（等价性测试或是键的相互比较）。在内循环不进行比较（极少）的情况下，我们会统计**数组的访问次数**。

**Sample clients.**  We consider two clients: a test client that we use to trace algorithm behavior on small inputs and a performance client.

- ***Test client.*** The `main()` client in each of our symbol table implementations reads in a sequence of strings from standard input, builds a symbol table by associating the value i with the ith key in the input, and then prints the table.

- ***Frequency counter.*** Program [FrequencyCounter.java](https://algs4.cs.princeton.edu/31elementary/FrequencyCounter.java.html) is a symbol-table client that finds the number of occurrences of each string (having at least as many characters as a given threshold length) in a sequence of strings from standard input, then iterates through the keys to find the one that occurs the most frequently.

`FrequencyCounter` 是一种常见的应用的代表，它的这些特性也是其他符号表应用的特性：

- 混合使用查找和插入的操作
- 大量的不同键
- 查找操作比插入操作多得多
- 虽然不可预测，但查找和插入操作的使用模式并非随机

### 无序列表中的顺序查找 Sequential search in an unordered linked list

**Sequential search in an unordered linked list.** Program [SequentialSearchST.java](https://algs4.cs.princeton.edu/31elementary/SequentialSearchST.java.html) implements a symbol table with a linked list of nodes that contain keys and values. To implement `get()`, we scan through the list, using `equals()` to compare the search key with the key in each node in the list. If we find the match, we return the associated value; if not, we return `null`. To implement `put()`, we also scan through the list, using `equals()` to compare the client key with the key in each node in the list. If we find the match, we update the value associated with that key to be the value given in the second argument; if not, we create a new node with the given key and value and insert it at the beginning of the list. This method is known as *sequential search*.

![linkedlist ST](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/linkedlistST.png)

上述通过链表实现的符号表 get 和 put 操作都要通过遍历链表来实现，这种为**顺序搜索（sequential search）。**使用 equals 方法来比较 key 是否相同。

分析符号表性能是，为了方便我们用命中（search hit）来表示一次成功的查找，未命中（search miss）来表示一次失败的查找。

**Proposition A.** Unsuccessful search and insert in an **(unordered) linked-list symbol table** both use N compares, and successful search uses N compares in the worst case. **In particular, inserting N keys into an initially empty linked-list symbol table uses ~N^2/2 compares.**

> We refer to such a search as a ***random search hit***. Though client search patterns are not likely to be random, they often are well-described by this model. It is easy to show that the average number of compares for a random search hit is ~ *N*/2: the get() method in Algo- rithm 3.1 uses 1 compare to find the first key, 2 compares to find the second key, and so forth, for an average cost of (1 + 2 + ... + *N* )/ *N* = (*N* + 1)/2 ~ *N*/2.

随机命中所需要的平均比较次数为 ～N/2，我们可以得知基于链表的实现以及顺序查找是非常低效的。

### 有序数组中的二分查找 Binary search in an ordered array

**Binary search in an ordered array**. Program [BinarySearchST.java](https://algs4.cs.princeton.edu/31elementary/BinarySearchST.java.html) implements the ordered symbol table API. The underlying data structure is two parallel array, with the keys kept in order. The heart of the implementation is the `rank()` method, which returns the number of keys smaller than a given key. For `get()`, the rank tells us precisely where the key is to be found if it is in the table (and, if it is not there, that it is not in the table). For `put()`, the rank tells us precisely where to update the value when the key is in the table, and precisely where to put the key when the key is not in the table. We move all larger keys over one position to make room (working from back to front) and insert the given key and value into the proper positions in their respective arrays.

 该实现的核心为rank算法，有递归和非递归两个版本

```java
public int rank(Key key) {
  if (key == null) throw new IllegalArgumentException("argument to rank() is null");

  int lo = 0;
  int hi = n - 1;
  while (lo <= hi) {
    int mid = lo + (hi - lo) / 2;
    int cmp = key.compareTo(keys[mid]);
    if (cmp < 0) hi = mid - 1;
    else if (cmp > 0) lo = mid + 1;
    else return mid;
  }
  return lo;
}

public int rank(Key key, int lo, int hi) {
  if (key == null) throw new IllegalArgumentException("argument to rank() is null");
  if (lo > hi) return lo;
  int mid = lo + (hi - lo) / 2;
  int cmp = key.compareTo(keys[mid]);
  if (cmp < 0) 
    return rank(key, lo, mid - 1);
  else if (cmp > 0) 
    return rank(key, mid + 1, hi);
  else 
    return mid;
}
```

rank() 保留了一下性质：

- 如果表中存在该键，rank 返回该键的位置，也就是表中小于它的键的数量
- 如果表中不存在该键，rank 还是应该返回表中小于它的键的数量

**非递归版本中循环在结束时 lo 的值正好等于表中小于被查找的键的数量。**

**Proposition B.** Binary search in an ordered array with N keys uses **no more than lg N + 1 compares** for a search (successful or unsuccessful) in the worst case.

**Proposition C.** Inserting a new key into an ordered array uses ~ 2N array accesses in the worst case, so **inserting N keys into an initially empty table uses ~ N^2 array accesses in the worst case.**

**二分查找减少了比较的次数，但是无法减少运行时间：因为它无法改变以下事实：在键是随机排列的情况下，构造一个基于有序数组的符号表所需访问数组的次数是数组长度的平方级别。**

#### 简单符号表实现的成本总结

![simple symbol table](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/simpleST.png)

**目前的核心问题在于我们能否同时保证查找和插入操作都是对数级别的算法和数据结构。要支持高效的插入操作，我们需要一种链式结构，但是单链接的链表是无法使用二分查找法的，因为二分查找的高效来自于能够快速通过索引取得任何子数组的中间元素（但得到一条链表的中间元素的唯一方法只能是沿链表遍历）。为了将二分查找的效率和链表的灵活性结合起来，我们需要更加复杂的数据结构，即二插查找树BFS。**

#### 符号表的各种实现的优缺点

![symbol table pros and cons](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/allST.png)

## 二叉查找树 Binary Search Trees

二叉查找树是一种能够将**链表插入的灵活性**和**有序数组查找的高效性**结合起来的符号表实现。

首先，我们定义一些术语：

> To begin, we define basic terminology. We are working with data structures made up of ***nodes*** that contain ***links*** that are either ***null*** or **references to other nodes**. In a ***binary tree***, we have the restriction that every node is pointed to by just one other node, which is called its ***parent*** (except for one node, **the *root*, which has no nodes pointing to it**), and that each node has exactly two links, which are called its ***left* and *right* links**, that point to nodes called its ***left child* and *right child***, respectively. Although links point to nodes, we can view each link as pointing to a binary tree, the tree whose root is the referenced node. Thus, we can **define a binary tree as either a null link or a node with a left link and a right link**, each references to (disjoint) *subtrees* that are themselves binary trees. **In a *binary search tree*, each node also has a key and a value, with an ordering restriction to support efficient search.**

我们所使用的数据结构由结点(nodes)组成，结点包含的链接(links)可以为空 null，或者指向其他结点。

**Definition.** A ***binary search tree* (BST)** is a binary tree where each node has a **Comparable key** (and an associated value) and satisfies the restriction that the **key in any node is larger than the keys in all nodes in that node’s left subtree and smaller than the keys in all nodes in that node’s right subtree.**

**二叉查找树每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意节点的键。**

### 基本实现

> Program [BST.java](https://algs4.cs.princeton.edu/32bst/BST.java.html) implements the ordered symbol-table API using a binary search tree. We define a inner private class to define nodes in BST. Each node contains a key, a value, a left link, a right link, and a node count. The left link points to a BST for items with smaller keys, and the right link points to a BST for items with larger keys. The instance variable `N` gives the node count in the subtree rooted at the node. This field facilitates the implementation of various ordered symbol-table operations, as you will see.

一颗二叉查找树代表了一组键（及其相应的值）的集合，而同一个集合可以用多颗不同的二叉查找树表示。

### 分析

使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。在最好的情况下，一颗含有N个结点的树是完全平衡的，没条空链接和根结点的距离都为~lgN。在最坏的情况下，搜索路径上可能有N个结点。

![BST analysis](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/BSTAnalysis.png)

对于二叉查找树的模型，和快速排序很像，树的根结点就是快速排序中的第一个切分元素

**Proposition.** Search hits in a BST built from N random keys requires ~ 2 ln N (about 1.39 lg N) compares on the average.

**Proposition.** Insertion and search misses in a BST built from N random keys requires ~ 2 ln N (about 1.39 lg N) compares on the average.

二叉查找树的插入和查找一个元素的复杂度都大约为 ~1.39lgN

给定一棵树，树的高度决定了所有操作在最坏情况下的性能

**Proposition.** Search, insertion, finding the minimum, finding the maximum, floor, ceiling, rank, select, delete the minimum, delete the maximum, delete, and range count operations all take time proportional to the **height of the tree**, in the worst case.

已经证明**随机键**构造的二叉查找树的平均高度为树中结点数的对数级别。**当N足够大时，这个值趋向于2.99lgN。**

但是在某些场景中，二叉查找树在最坏情况下的恶劣性能仍然是不可接受的。**二叉查找树的基本实现的良好性能依赖于其中键的分布足够随机以消除长路径。**对于快速排序，我们可以先将数组打乱，而对于符号表的API。我们无能为力，因为调用API的顺序是由用例决定的，**最坏情况在实际应用中也可能出现——用例将所有键安装顺序或者逆序插入符号表就会增加这种情况出现的概率。**

### 性能分析

![cost summary](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/costsummary.png)

## 平衡查找树 Balanced Search Trees

本节介绍一种二分查找树并**保证无论如何构造它，它的运行时间都是对数级别的。**

### 2-3查找树

为了树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。我们将一颗保证的二叉查找树中的结点称为**2-结点（含有一个键和两条链接）**，现在引入**3-结点，它含有两个键和三条链接**。2-结点和3-结点中的每条链接都对应着其中保存的键所分割产生的一个区间。

> **Definition.**
>
>  A *2-3 search tree* is a tree that either is empty or:
>
> - A *2-node*, with one key (and associated value) and two links, a left link to a 2-3 search tree with smaller keys, and a right link to a 2-3 search tree with larger keys
> - A *3-node*, with two keys (and associated values) and three links, a left link to a 2-3 search tree with smaller keys, a middle link to a 2-3 search tree with keys between the node's keys and a right link to a 2-3 search tree with larger keys.

![2-3 tree](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/2-3tree.png)

A *perfectly balanced* 2-3 search tree (or 2-3 tree for short) is one whose null links are all the same distance from the root.

**局部变换 Local transformations**

2-3树插入算法的根本在于这些变换都是局部的：处理相关的结点和链接之外不必修改或者检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数。每个变换都会将4-结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。

**全局性质 Global propreties**

这些局部变换不会影响树的**全局有序性（global ordered）和平衡性（balanced）**：**任意空链接到根结点的路径长度都是相等的。**

**Proposition.** **Search and insert** operations in a 2-3 tree with N keys are guaranteed to visit **at most lg N nodes.**

我们可以确定 2-3树在最坏的情况下仍有比较好的性能。

![2-3 tree](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/2-3tree2.png)

### 红黑二叉查找树

#### 替换 3-结点

红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。**我们将树中的链接分为两种类型：红链接将两个2-结点链接起来构成一个3-结点，黑链接则是2-3树中的普通链接。确切地说，我们将3-结点表示为用一条左斜的红色链接（两个2-结点其中之一是另一个的左子结点）链接起来的两个2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。对于任意一颗2-3树，只要对结点进行转换，我们都可以立即派生出一颗二叉查找树。这种树称为红黑二叉树。**

![black red tree](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/algorithms/blackRedTree.png)

红黑树的另一种定义是含有红黑树链接并满足下列条件的二叉查找树：

- 红链接均为左链接
- 没有任何一个结点同时和两条红链接相连
- 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑色链接数量相同。

无论用何种方式去定义，红黑树都即使二叉查找树，也是2-3树，因此可以将两个算法的优点结合起来：**二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。**

当我们提到一个结点的颜色时，我们指的是指向该结点的链接的颜色。

#### 旋转

在插入新的键时我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保证红黑树的两个重要性质：有序性（ordered）和完美平衡性（perfect black balance）

还可以保证其他两个性质：

- 不存在两条连续的红链接
- 不存在红色的右链接

#### 颜色转换

除了将子结点的颜色有红遍黑外，我们同事还要将父结点的颜色由黑变红，**这项操作的重要性质在于，她和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性。**

#### 根结点总是黑色

我们在每次插入后都会将根结点设为黑色。注意，每当根结点右红变黑时树的黑链接高度就会加1.

在插入新结点时总是用红链接将新结点与其父结点相连，

在沿着插入点到根结点的路径向上移动时所经过的每个结点中顺序完成一下操作，我们就能完成插入操作：

- If the right child is red and the left child is black, rotate left.
- If both the left child and its left, child are red, rotate right.
- If both children are red, flip colors.

![passing a red link up](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/algorithms/passingARedLinkup.png)

```java
// insert the key-value pair in the subtree rooted at h
private Node put(Node h, Key key, Value val) { 
  if (h == null) return new Node(key, val, RED, 1);

  int cmp = key.compareTo(h.key);
  if      (cmp < 0) h.left  = put(h.left,  key, val); 
  else if (cmp > 0) h.right = put(h.right, key, val); 
  else              h.val   = val;

  // fix-up any right-leaning links
  if (isRed(h.right) && !isRed(h.left))      h = rotateLeft(h);
  if (isRed(h.left)  &&  isRed(h.left.left)) h = rotateRight(h);
  if (isRed(h.left)  &&  isRed(h.right))     flipColors(h);
  h.size = size(h.left) + size(h.right) + 1;

  return h;
}
```

### 红黑树的性质

所有基于红黑树的符号表的实现都能保证操作的运行时间为对数级别（范围查找除外，它所需的往外时间和返回的键的数量成正比）

> **propositionG.** The **height** of a red-black BST with *N* nodes is no more than **2lg*N*.**
>
> **proofsketch:** Theworstcaseisa2-3treethatisall2-nodesexceptthattheleftmost path is made up of 3-nodes. The path taking left links from the root is twice as long as the paths of length ~ lg *N* that involve just 2-nodes. It is possible, but not easy, to develop key sequences that cause the construction of red-black BSTs whose average path length is the worst-case 2 lg *N.* If you are mathematically inclined, you might enjoy exploring this issue by working Exercise 3.3.24.

无论键的插入顺序如何，红黑树都几乎时完美平衡的。红黑树最坏的情况时它所对于的2-3树中构成最左边的路径结点全部都是3-结点，而其余均为2-结点。

> **property H.** The **average length** of a path from the root to a node in a red-black BST with *N* nodes is **~1.00 lg *N*.**
>
> **Evidence:** Typical trees, such as the one at the bottom of the previous page (and even the one built by inserting keys in increasing order at the bottom of this page) are quite well-balanced, by comparison with typical BSTs (such as the tree depicted on page 405). The table at the top of this page shows that path lengths (search costs) for our FrequencyCounter application are about 40 percent lower than from el- ementary BSTs, as expected. This performance has been observed in countless ap- plications and experiments since the invention of red-black BSTs.

> **proposition i.** In a red-black BST, the following operations take **logarithmic time** in the worst case: search, insertion, finding the minimum, finding the maximum, floor, ceiling, rank, select, delete the minimum, delete the maximum, delete, and range count.
>
> **proof:** We have just discussed get(), put(), and the deletion operations. For the others, the code from Section 3.2 can be used *verbatim* (it just ignores the node color). Guaranteed logarithmic performance follows from Propositions E and G, and the fact that each algorithm performs a constant number of operations on each node examined.

![cost summary](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/algorithms/costSummary3.png)

## 散列表

