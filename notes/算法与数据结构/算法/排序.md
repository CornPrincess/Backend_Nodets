## 归并排序

> The algorithms that we consider in this section is based on a simple operation known as *merging*: combining two ordered arrays to make one larger ordered array. This operation immediately lends itself to a simple recursive sort method known as *mergesort*: to sort an array, divide it into two halves, sort the two halves (recursively), and then merge the results.
>
> Mergesort guarantees to sort an array of N items in time proportional to N log N, no matter what the input. Its prime disadvantage is that it uses extra space proportional to N.

在本节中我们讨论的算法都基于归并（merging）这个操作：即将两个有序的数组并成一个更大的有序数组。人们根据这个操作发明了**归并排序**：将数组递归地分成两半进程排序，然后将结果归并起来。

**归并排序最吸引人的地方在于他能够保证将任意长度为N的数组排序所需时间和NlogN成正比，他的主要缺点为需要的额外空间与N成正比。**

![mergesort overview](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/mergesort.png)

### 原地归并的抽象方法 Abstract in-place merge

实现归并的一种直截了当的方法是将两个数组中的元素归并到第三个数组中，这种做法在递归过程中会占用很多空间，最好使用原地归并的方法。

以下方法merge(a, lo, mid, hi)会将子数组a[lo...mid]和a[mid+1...hi]归并成一个有序数组并将结果存放在a[lo...hi]中

```java
public static void merge(Comparable[] a, int lo, int mid, int hi) {
  int i = lo;
  int j = mid + 1;
  for (int k = lo; k <= hi; k++) {
    aux[k] = a[k];
  }

  for (int k = lo; k <=hi; k++) {
    // left side use out, use right side
    if (i > mid) {
      a[k] = aux[j++];
      // right side use out, use left side
    } else if (j > hi) {
      a[k] = aux[i++];
      // right side number smaller than left side number, use right side 
    } else if (less(aux[j], aux[i])) {
      a[k] = aux[j++];
      // left side number smaller than right side number, use left side
    } else {
      a[k] = aux[i++];
    }
  }
}
```

该方法将所有的元素都复制到aux[]中，然后再归并到a[]中，方法在归并时使用了四种判断：

- 左半边取尽，取右半边男男女女你的元素
- 右半边用尽，取左半边的元素
- 右半边的当前元素小于左半边的当前元素，取右半边元素
- 右半边的当前元素大于左半边的当前元素，取左半边元素

![merge trace](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/mergetrace.png)

### 自顶向下的归并排序 Top-down mergesort

这段递归代码时归纳证明算法能够正确地将数组排序的基础：如果它能将两个子数组排序，它将能够通过归并两个子数组来将整个数组排序。

这段高效代码使用了分治的思想（divide-and-conquer）

```java
public class TopDownMerge {
    private static Comparable[] aux;

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) {
            return;
        }

        int mid = lo + (hi - lo) / 2;
        sort(a, lo, mid);
        sort(a, mid + 1, hi);
        merge(a, lo, mid, hi);
    }
}
```

![top-downMerge](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/topdownMerge.png)

**Proposition**.

 Top-down mergesort uses between 1/2 N lg N and N lg N compares and at most 6 N lg N array accesses to sort any array of length N.

**Improvements**.

 We can cut the running time of mergesort substantially with some carefully considered modifications to the implementation.

- *Use insertion sort for small subarrays.* We can improve most recursive algorithms by handling small cases differently. Switching to insertion sort for small subarrays will improve the running time of a typical mergesort implementation by 10 to 15 percent.
- *Test whether array is already in order.* We can reduce the running time to be linear for arrays that are already in order by adding a test to skip call to `merge()` if `a[mid]` is less than or equal to `a[mid+1]`. With this change, we still do all the recursive calls, but the running time for any sorted subarray is linear.
- *Eliminate the copy to the auxiliary array.* It is possible to eliminate the time (but not the space) taken to copy to the auxiliary array used for merging. To do so, we use two invocations of the sort method, one that takes its input from the given array and puts the sorted output in the auxiliary array; the other takes its input from the auxiliary array and puts the sorted output in the given array. With this approach, in a bit of mindbending recursive trickery, we can arrange the recursive calls such that the computation switches the roles of the input array and the auxiliary array at each level.

[MergeX.java](https://algs4.cs.princeton.edu/22mergesort/MergeX.java.html) implements these improvements.

![top down mergesort trace](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/topdownMergeTrace.png)

### 自底向上的归并排序 Bottom-up mergesort

This method requires even less code than the standard recursive implementation. We start by doing a pass of 1-by-1 merges (considering individual items as subarrays of size 1), then a pass of 2-by-2 merges (merge subarrays of size 2 to make subarrays of size 4), then 4-by-4 merges, and so forth. [MergeBU.java](https://algs4.cs.princeton.edu/22mergesort/MergeBU.java.html) is an implementation of bottom-up mergesort.

```java
public static void sort(Comparable[] a) {
  int n = a.length;
  Comparable[] aux = new Comparable[n];
  for (int len = 1; len < n; len *= 2) {
    for (int lo = 0; lo < n - len; lo += len + len) {
      int mid = lo + len - 1;
      int hi = Math.min(lo + len + len - 1, n - 1);
      merge(a, aux, lo, mid, hi);
    }
  }
}
```

**Proposition**.

 Bottom-up mergesort uses between 1/2 N lg N and N lg N compares and at most 6 N lg N array accesses to sort any array of length N.



**Proposition.**

 No compare-based sorting algorithm can guarantee to sort N items with fewer than lg(N!) ~ N lg N compares.



**Proposition.**

 Mergesort is an asymptotically optimal compare-based sorting algorithm. That is, both the number of compares used by mergesort in the worst case and the minimum number of compares that any compare-based sorting algorithm can guarantee are ~N lg N.

![bottom up merge trace](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/bottomupMerge.png)

自底向上的归并比较适合链表

## 快速排序

Quicksort is popular because it is not difficult to implement, works well for a variety of different kinds of input data, and is substantially faster than any other sorting method in typical applications. It is **in-place (uses only a small auxiliary stack),** requires time proportional to **N log N** on the average to sort N items, and has an extremely short inner loop.

### 基本算法

快速排序是一种分治的算法，它将一个数组分成两个子数组，将两部分独立排序，与归并排序不同的是，当两个子数组有序时整个数组就有序了 。递归调用发生在处理数组之后在快速排序中，切分（partition）的位置取决于数组的内容。

```java
public static void sort(Comparable[] a) {
  StdRandom.shuffle(a);
  sort(a, 0, a.length - 1);
  assert isSorted(a);
}

private static void sort(Comparable[] a, int lo, int hi) {
  if (hi <= lo) {
    return;
  }
  int j = partition(a, lo, hi);
  sort(a, lo, j - 1);
  sort(a, j + 1, hi);
  assert isSorted(a, lo, hi);
}
```



![quick sort overview](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/quicksortOverview.png)

这个算法的关键在于partition()算法的实现，这一过程使得数组满足以下三个条件：

- The entry `a[j]` is in its **final** place in the array, for some j
- No entry in `a[lo]` through `a[j-1]` is greater than `a[j]`
- No entry in `a[j+1]` through `a[hi]` is less than `a[j]`.

To complete the implementation, we need to implement the partitioning method. We use the following general strategy: 

- First, we arbitrarily choose `a[lo]` to be the partitioning item—the one that will go into its final position. 
- Next, we scan from the left end of the array until we find an entry that is greater than (or equal to) the partitioning item, and we scan from the right end of the array until we find an entry less than (or equal to) the partitioning item.
- The two items that stopped the scans are out of place in the final partitioned array, so we exchange them.
- When the scan indices cross, all that we need to do to complete the partitioning process is to exchange the partitioning item `a[lo]` with the rightmost entry of the left subarray (`a[j]`) and return its index `j`.

![partition](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/partition.png)

```java
private static int partition(Comparable[] a, int lo, int hi) {
  int i = lo;
  int j = hi+1;
  Comparable v = a[lo];
  while (true) {
    while (less(a[++i], v)) {
      if (i == hi) break;
    }
    while (less(v, a[--j])) {
      if (j == lo) break;
    }
    if (i >= j) break;
    exch(a, i, j);
  }
  exch(a, lo, j);
  return j;
}
```

![partiton trace](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/partitionTrace.png)

![partition trace2](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/partitionTrace2.png)

**算法注意点**：见Reference

算法改进：

- 切换到插入排序 *Cutoff to insertion sort*：将 `if (hi <= lo) return;` 改为 `if (hi <= lo + M) Insertion(a, lo, hi); return;`M一般为5-15之间
- 三取样切分 *Median-of-three partitioning*
- 熵最优的排序： One straightforward idea is to **partition the array into three parts**三项切分, one each for items with keys smaller than, equal to, and larger than the partitioning item's key. Accomplishing this partitioning was a classical programming exercise popularized by E. W. Dijkstra as the **Dutch National Flag problem**, because it is like sorting an array with three possible key values, which might correspond to the three colors on the flag.

三向切分的快速排序

```java
private static void sort(Comparable[] a, int lo, int hi) {
  if (hi <= lo) return;
  int lt = lo, gt = hi;
  Comparable v = a[lo];
  int i = lo + 1;
  while (i <= gt) {
    int cmp = a[i].compareTo(v);
    if      (cmp < 0) exch(a, lt++, i++);
    else if (cmp > 0) exch(a, i, gt--);
    else              i++;
  }

  // a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi].
  sort(a, lo, lt-1);
  sort(a, gt+1, hi);
  assert isSorted(a, lo, hi);
}
```



## Reference

1. [Quicksort](https://algs4.cs.princeton.edu/23quicksort/)

