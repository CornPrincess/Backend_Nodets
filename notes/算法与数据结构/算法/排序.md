# 排序

在计算机早期，大家普遍认为30%的计算周期都用在了排序上。如果今天这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序算法的重要性降低了。

## 初级排序算法

> ## Rules of the game.
>
>  Our primary concern is algorithms for rearranging arrays of items where each item contains a *key*. The objective is to rearrange the items such that their keys are in ascending order. In Java, the abstract notion of a key is captured in a built-in mechanism—the `Comparable` interface. With but a few exceptions, our sort code refers to the data only through two operations: the method `less()` that compares objects and the method `exch()` that exchanges them.

- 对于每一种算法，我们都将采用如下的模型

```java
public class Example {
    public static void sort(Comparable[] a){}

    public static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    public static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    public static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
        System.out.println();
    }

    public static boolean isSorted(Comparable[] a) {
        for (int i = 1; i < a.length; i++) {
            if (less(a[i], a[i-1])) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        String[] a = In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
```

- 排序成本模型：在研究排序算法时，我们需要计算比较和交换的数量。对于不交换元素的算法，我们会计算访问数组的次数。
- 额外内存：排序算法分为两类：除了函数调用所需要的栈和固定数目的实例变量之外无需额外内存的原地排序算法（in place）和其他类型算法。
- 数据类型：此算法模板适用于任何实现了Comparable接口的数据类型，compareTo方法实现了主键抽象。*Types of data.* Our sort code is effective for any type of data that implements Java's [Comparable interface](http://download.oracle.com/javase/6/docs/api/java/lang/Comparable.html). This means that there is a method `compareTo()` for which `v.compareTo(w)` returns an integer that is negative, zero, or positive when v < w, v = w, or v > w, respectively. The method must implement a *total order（全序关系）*:
  - *Reflexive 自反性:* for all v, v = v.
  - *Antisymmetric:* 反对称性 for all v and w, if (v < w) then (w > v); and if (v = w) then (w = v).
  - *Transitive 传递性:* for all v, w, and x, if (v ≤ w) and (w ≤ x), then v ≤ x.

### 选择排序

```java
public static void sort(Comparable[] a){
    int N = a.length;
    for (int i = 0; i < N; i++) {
        int min = i;
        for (int j = i+1; j < N; j++) {
            if (less(a[j], a[min])) {
                min = j;
            }
        }
        exch(a, i, min);
        assert isSorted(a, 0, i);
    }
    assert isSorted(a);
}
```

**Proposition**: Selection sort uses ~n<sup>2</sup>/2 compares and n exchanges to sort an array of length n.

- [ ] 补图

### 插入排序

通常人们整理桥牌的方法是一张一张来，将每一张牌插入到其他已经有序的牌中的适当位置，在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入前都向右移动一位。这种算法叫作插入排序。输入元素对于排序时间影响较大。

```java
public static void sort(Comparable[] a) {
    int N = a.length;
    for (int i = 1; i < N; i++) {
        for (int j = i; j > 0 && less(a[j], a[j-1]); j--) {
            exch(a, j, j-1);
        }
        assert isSorted(a);
    }
    assert isSorted(a);
}
```

- [ ] 补图

**Proposition：**

 For randomly ordered arrays of length N with with distinct keys, insertion sort uses ~N<sup>2</sup>/4 compares and ~N<sup>2</sup>/4 exchanges on the average. The worst case is ~ N<sup>2</sup>/2 compares and ~ N<sup>2</sup>/2 exchanges and the best case is N-1 compares and 0 exchanges.

Insertion sort works well for certain types of nonrandom arrays that often arise in practice, even if they are huge. An *inversion* is a pair of keys that are out of order in the array. For instance, E X A M P L E has 11 inversions: E-A, X-A, X-M, X-P, X-L, X-E, M-L, M-E, P-L, P-E, and L-E. If the number of inversions in an array is less than a constant multiple of the array size, we say that the array is *partially sorted*.

### 比较两种排序算法

**Property:**

 For randomly ordered arrays of distinct values, the running times of insertion sort and selection sort are quadratic and within a small constant factor of one another.

### Visualizing sorting algorithms.

 We use a simple visual representation to help describe the properties of sorting algorithms. We use vertical bars, to be sorted by their heights. [SelectionBars.java](https://algs4.cs.princeton.edu/21elementary/SelectionBars.java.html) and [InsertionBars.java](https://algs4.cs.princeton.edu/21elementary/InsertionBars.java.html) produce these visualizations.

### 希尔排序

希尔排序基于插入排序，对于大规模乱序数组插入排序很慢，因为它只会交换向量的元素，因此数组只能一点一点从一端移动到另一端。**希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序 的数组排序。**

希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组，即一个h有序数组就是h个互相独立的有序数组编织在一起组成的数组。

希尔排序更高效的原因是它权衡了子数组的规模和有序性。子数组部分有序的程度取决于递增序列的选择。

```java
public static void sort(Comparable[] a) {
    int n = a.length;
    // 3x + 1 increment sequence: 1, 4, 13 , 40, 121
    int h = 1;
    while (h < n/3) {
        h = h * 3 + 1;
    }

    while (h >= 1) {
        // h-sort the array
        for (int i = h; i < n; i++) {
            for (int j = i; j >= h && less(a[j], a[j-h]); j -= h) {
                exch(a, j, j-h);
            }
        }
        assert isHsorted(a, h);
        h /= 3;
    }
    assert isSorted(a);
}
```

希尔排序的例子说明：**通过提示速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一。**

对于中等大小数组，希尔排序的速度是可以接受的，其他高效的算法，对于很大的N，可能只会比希尔排序快两倍。

**Property:**

 The number of compares used by shellsort with the increments 1, 4, 13, 40, 121, 364, ... is bounded by a small multiple of N times the number of increments used.

**Proposition:**

 The number of compares used by shellsort with the increments 1, 4, 13, 40, 121, 364, ... is O(N3/2).



todo 荷兰国旗问题

## 优先队列

Many applications require that we process items having keys in order, but not necessarily in full sorted order and not necessarily all at once. Often, we collect a set of items, then process the one with the largest key, then perhaps collect more items, then process the one with the current largest key, and so forth. **An appropriate data type in such an environment supports two operations: *remove the maximum* and *insert*. Such a data type is called a *priority queue*.**

### API

 **Priority queues are characterized by the *remove the maximum* and *insert* operations.** By convention, we will compare keys only with a `less()` method, as we have been doing for sorting. **Thus, if records can have duplicate keys, *maximum* means *any* record with the largest key value.** To complete the API, we also need to add constructors and a *test if empty* operation. For flexibility, we use a generic implementation with a generic type `Key` that implements `Comparable`.

- [ ] 补图

Program [TopM.java](https://algs4.cs.princeton.edu/24pq/TopM.java.html) is a priority queue client that takes a command-line argument *M*, reads transactions from standard input, and prints out the *M* largest transactions.

我们考虑以下模型：输入N个字符串，每个字符串都对应一个整数，任务是从中找出最大的M个整数及其关联的字符串。我们任务输入量是巨大的，甚至认为是无限的。我们可以高效地实现优先队列中的`insert()` 和`delMin()`

从N个输入中找到最大的M个元素所需的成本

|         示例         | 时间成本 | 空间成本 |
| :------------------: | :------: | :------: |
|       排序算法       |  NlogN   |    N     |
|  初级实现的优先队列  |    NM    |    M     |
| 基于堆实现的优先队列 |  NlogM   |    M     |

数组和列表的初级实现中，插入元素和删除元素这两个操作之一在最坏情况下需要线性时间完成。

### 堆的定义

**Heap definitions.**  The *binary heap* 二叉堆is a data structure that can efficiently support the basic priority-queue operations. In a binary heap, the items are stored in an array such that each key is guaranteed to be larger than (or equal to) the keys at two other specific positions. In turn, each of those keys must be larger than two more keys, and so forth. This ordering is easy to see if we view the keys as being in a binary tree structure with edges from each key to the two keys known to be smaller.

**Definition.** A binary tree is ***heap-ordered*** if the key in each node is larger than (or equal to) the keys in that nodes two children (if any).

**Proposition.** The largest key in a heap-ordered binary tree is found at the root.

**Definition.** A *binary heap* is a set of nodes with keys arranged in a complete heap-ordered binary tree, represented in level order in an array (not using the first entry).

- [ ] 补图

**In a heap, the parent of the node in position k is in position k/2; and, conversely, the two children of the node in position k are in positions 2k and 2k + 1. We can travel up and down by doing simple arithmetic on array indices: to move up the tree from a[k] we set k to k/2; to move down the tree we set k to 2*k or 2*k+1.**

- *Bottom-up reheapify (swim).*

```java
private void swim(int k) {
    while (k > 1 && less(k/2, k)) {
        exch(k/2, k);
        k = k / 2;
    }
}
```

- *Top-down heapify (sink).*

```java
private void sink(int k) {
    while (2*k <= N) {
        int j = 2*k;
        if (j < N && less(j, j+1)) j++;
        if (!less(k, j)) break;
        exch(k, j);
        k = j;
    }
}
```



### 堆的算法

 We represent a heap of size *n* in private array `pq[]` of length *n* + 1, with `pq[0]` unused and the heap in `pq[1]` through `pq[n]`. We access keys only through private helper functions `less()` and `exch()`. The heap operations that we consider work by first making a simple modification that could violate the heap condition, then traveling through the heap, modifying the heap as required to ensure that the heap condition is satisfied everywhere. We refer to this process as *reheapifying*, or *restoring heap order*.

 These `sink()` and `swim()` operations provide the basis for efficient implementation of the priority-queue API, as diagrammed below and implemented in [MaxPQ.java](https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html) and [MinPQ.java](https://algs4.cs.princeton.edu/24pq/MinPQ.java.html).

- *Insert.* We add the new item at the end of the array, increment the size of the heap, and then swim up through the heap with that item to restore the heap condition.
- *Remove the maximum.* We take the largest item off the top, put the item from the end of the heap at the top, decrement the size of the heap, and then sink down through the heap with that item to restore the heap condition.

- [ ] 补图

**Proposition.** In an *n*-item priority queue, the heap algorithms require no more than 1 + lg *n* compares for *insert* and no more than 2 lg *n* compares for *remove the maximum*.

### 堆排序

堆排序一共有两个阶段，第一阶段为堆的构造，第二阶段为下沉排序

- **Heap construction:** We can accomplish this task in time proportional to nlgn ,by proceeding from left to right through the array, using swim() o ensure that the entries to the left of the scanning pointer make up a eap-ordered complete tree, like successive priority queue insertions. **A clever method that is much ore efficient is to proceed from right to left, using sink() to make subheaps as we go.** Every position in the array is the root of a small subheap; sink()  works or such subheaps, as well. If the two children of a node are heaps, then calling  sink() on that node makes the subtree rooted there a heap.
- **Sortdown**. Most of the work during heapsort is done during the second phase, where we remove the largest remaining items from the heap and put it into the array position vacated as the heap shrinks.

```java
public static void sort(Comparable[] pq) {
    int n = pq.length;
    // heapify phase
    for (int k = n/2; k >= 1; k--) {
        sink(pq, k, n);
    }

    // sortdown phase
    int k = n;
    while (k > 1) {
        exch(pq, 1, k--);
        sink(pq, 1, k);
    }
}
```

[Heap.java](https://algs4.cs.princeton.edu/24pq/Heap.java.html) is a full implementation of heapsort. Below is a trace of the contents of the array after each sink.

堆排序是唯一能同时最优地利用空间和时间的方法。但空间紧张时，特别是在嵌入式系统中，它有较好的性能，但在现代操作系统中和的很多应用很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数远远高于大多数比较都在相邻元素间进行的算法，如快速排序，归并排序，甚至是希尔排序。

## 应用

### 稳定性

***Stability*** **A sorting method is *stable* if it preserves the relative order of equal keys in the array.** For example, suppose, in our internet commerce application, that we enter transactions into an array as they arrive, so they are in order of the time field in the array. Now suppose that the application requires that the transactions be separated out by location for further processing. One easy way to do so is to sort the array by location. If the sort is unstable, the transactions for each city may not necessarily be in order by time after the sort. Some of the sorting methods that we have considered in this chapter are stable (insertion sort and mergesort); many are not (selection sort, shellsort, quicksort, and heapsort).

## Reference

1.  [Elementary Sorts](https://algs4.cs.princeton.edu/21elementary/)
2. [Algorithms and Data Structures Cheatsheet](https://algs4.cs.princeton.edu/cheatsheet/)
