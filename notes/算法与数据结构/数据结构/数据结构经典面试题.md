[TOC]

# Array & Linked List

## [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

反转链表，主要考察链表的基本操作，可以使用迭代与递归两种方法。

### Iterative

Time complexity: O(n)

Space complexity: O(1)

```java
public ListNode iterate(ListNode head) {
  ListNode curr = head;
  ListNode pre = null;
  while (curr != null) {
    ListNode nextTmp = curr.next;
    curr.next = pre;
    pre = curr;
    curr = nextTmp;
  }
  return pre;
}
```

### Recursive

Time complexity: O(n)

Space complexity: O(n)，由于使用递归，因此会使用隐式栈空间，栈递归调用最多会有n次。

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
```

## [24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)

将链表中相邻的两个数两两交换，也是用到链表的基本操作，可以用迭代和递归两种方法

### Iterative

Time complexity: O(n)

Space complexity: O(1)

```java
public ListNode swapPairs(ListNode head) {
  ListNode dummy = new ListNode(-1);
  dummy.next = head;
  ListNode prevNode = dummy;

  while (head != null && head.next != null) {
    // nodes to be swapper
    ListNode firstNode = head;
    ListNode secondNode = head.next;

    // swap nodes
    prevNode.next = secondNode;
    firstNode.next = secondNode.next;
    secondNode.next = firstNode;

    // Reinitializing the head and prevNode for next swap
    prevNode = firstNode;
    head = firstNode.next;
  }
  return dummy.next;
}
```

### Recursive

算法：

- 从链表的头节点 head 开始递归。
- 每次递归都负责交换一对节点。由 firstNode 和 secondNode 表示要交换的两个节点。
- 下一次递归则是传递的是下一对需要交换的节点。若链表中还有节点，则继续递归。
- 交换了两个节点以后，返回 secondNode，因为它是交换后的新头。
- 在所有节点交换完成以后，我们返回交换后的头，实际上是原始链表的第二个节点。

Time complexity: O(n)

Space complexity: O(n)，由于使用递归，因此会使用隐式栈空间，栈递归调用最多会有n次。

```java
public ListNode recursive(ListNode head) {
  // If the list has no node or has only one left.
  if (head == null || head.next == null) {
  	return head;
  }

  // nodes to be swapped
  ListNode firstNode = head;
  ListNode secondNode = head.next;

  // swap
  // 除了前两个，后面的节点都已经做好两两交换
  firstNode.next = recursive(secondNode.next);
  secondNode.next = firstNode;

  // now the head is second node
  return secondNode;
}
```

## [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

### Brute force

函数中对链表进行遍历，自定义函数执行时间，例如 0.5s， 如果遍历到 null， 则含有环，否则没有环，当然这种方法在面试中不能使用。



### HashSet

思路：对链表进行遍历，并将每个链表节点的引用存放在 set 中，遍历时进行判断，若存在于 set 中，则有环，否则无环。

Time complexity: O(n)

Space complexity: O(n)

```java
public boolean hasCycle(ListNode head) {
        Set<ListNode> nodesSeen = new HashSet<>();

        while (head != null) {
            if (nodesSeen.contains(head)) {
                return true;
            } else {
                nodesSeen.add(head);
            }
            head = head.next;
        }
        return false;
    }
```

### Two Points

利用快慢指针进行判断，如果有环则快慢指针最终一定会相遇。

Time complexity: O(n)

Space complexity: O(1)

```java
public boolean twoPoint(ListNode head) {
  ListNode slow = head;
  ListNode fast = head.next;

  while (slow != fast) {
  if (fast == null || fast.next == null) {
  	return false;
  }
    slow = slow.next;
    fast = fast.next.next;
  }
  return true;
}
```



## [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)

这道题与上一题很相似，思路也是一样的，只是需要返回环的起点。


### HashSet

对链表进行遍历，如果成环，则返回第一个存在与hashSet中的节点，不成环则返回null。

Time complexity: O(n)

Space complexity: O(n)

```java
public ListNode detectCycle(ListNode head) {
Set<ListNode> visited = new HashSet<>();

  while (head != null) {
    if (visited.contains(head)) {
      return head;
    }
    visited.add(head);
    head = head.next;
   }
  return null;
}
```

### Floyd

使用双指针的方法找到快慢节点相遇的节点，然后根据公式就算除环入口在哪。

![Floyd](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/LinkedListCycleii.png)

Time complexity: O(n)

Space complexity: O(1)

```java
public ListNode floyd(ListNode head) {
  if (head == null) {
  	return null;
  }

  ListNode intersect = getIntersect(head);

  if (intersect == null) {
  	return null;
  }

  ListNode start = head;

  while (start != intersect) {
    start = start.next;
    intersect = intersect.next;
  }
  return start;
}

private ListNode getIntersect(ListNode head) {
  ListNode slow = head;
  ListNode fast = head;

  while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
    if (fast == slow) {
    	return fast;
  	}
  }
  return null;
}
```

#### ## [202. Happy Number](https://leetcode-cn.com/problems/happy-number/)

题型与141， 142类似，这里不再给出代码，想要源码可以到 [LeetCode](https://github.com/CornPrincess/LeetCode) 库中查看



## 