# 堆

## 相关概念

首先堆需要满足两个条件：

- 堆是一个完全二叉树
- 堆中每一个节点的值都必须大于等于（或小于等于其字数中的每个节点的值）（堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。）

堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。

对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。

对于同一组数据，我们可以构建多种不同形态的堆。

堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。

## 堆化 heapify

### 插入元素 从下往上 swim

堆化其实很简单，就是顺着节点所在路径，向上或者向下，对比，然后交换

![heap](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/heap.png)

这幅图描述了swim 向上堆化的过程，即将插入的节点一直和父节点进行比较，直到满足大小关系才停下。

### 删除元素 从上往下 sink

这种堆化的过程一般出现在堆顶元素的删除操作中，当将堆顶元素删除以后，我们需要进行 sink 操作来保持堆的特性，具体可以分为两步：

- 将堆中最后一个元素填入堆顶
- 自上而下进行调整，即sink

![sink](https://blog-1300663127.cos.ap-shanghai.myqcloud.com/BackEnd_Notes/JavaSE/sink.png)

**我们知道，一个包含 n 个节点的完全二叉树，树的高度不会超过 log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。**

## 堆排序

利用堆这种数据结构进行排序的排序方法称为堆排序，有以下特点：

- 时间复杂度非常稳定：o(nlogn)
- 原地排序算法

看上去是结合了快速排序和归并排序的优点，堆排序一共有两大步骤：

### 建堆

建堆有两种思路：

- 假设一开始堆中只有一个数据，即下标为1的数据，此时依次向堆中插入数据，这是一种**从前向后处理**的思路，并且每次处理，都要进行一次 **swim （从下往上堆化）**的过程
- **从后先前处理**数据，并且每个数据都是**从上往下堆化 sink**

```java
public static void  buildHeap(int[] a, int n) {
  for (int i = n / 2; i >= 1; i--) {
    heapify(a, n, i);
  }
}

private static void heapify(int[] a, int n, int i) {
  while (true) {
    int maxPos = i;
    if (i * 2 <= n && a[maxPos] < a[i * 2]) {
      maxPos = i * 2;
    }
    if (i * 2 + 1 <= n && a[maxPos] < a[i * 2 + 1]) {
      maxPos = i * 2 + 1;
    }
    if (maxPos == i) {
      break;
    }
    i = maxPos;
  }
}
```

**排序的建堆过程的时间复杂度是 O(n)。**

### 排序

建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。

这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。

```java
// n表示数据的个数，数组a中的数据从下标1到n的位置。
public static void sort(int[] a, int n) {
  buildHeap(a, n);
  int k = n;
  while (k > 1) {
    swap(a, 1, k);
    --k;
    heapify(a, k, 1);
  }
}
```

整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，**堆排序整体的时间复杂度是 O(nlogn)。**

**堆排序不是稳定的排序算法，**因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

## 堆的用途

### 优先队列

### TopK

### 中位数

## 面试题

快速排序，平均情况下，它的时间复杂度为 O(nlogn)。尽管这两种排序算法的时间复杂度都是 O(nlogn)，甚至堆排序比快速排序的时间复杂度还要稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？

上述问题原因有两个：

- 堆排序数据访问的方式没有快速排序友好：快排可以局部顺序访问，但是堆排是跳着访问的，所以堆排对于CPU缓存是不友好的
- 对于同样的数据，堆排的数据交换次数多于快排