# 背包、队列和栈

## API

![Bag Queue Stack API](/Users/zhoutianbin/Library/Application Support/typora-user-images/image-20200723232539285.png)

> A *bag* is a collection where removing items is not supported—its purpose is to provide clients with the ability to collect items and then to iterate through the collected items.

### 背包 Bag

背包是一种不支持从中删除元素的集合数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素，迭代的顺序不确定且与用例无关。

要理解背包的概念，可以想象一个非常喜欢收集弹子球的人 。他将所有弹子球都放在一个背包里，一次一个，并且会不时在所有的弹子球中寻找一颗拥有某种特点的弹子球。

```java
public class Stats {
    public static void main(String[] args) {

        // read in numbers
        Bag<Double> numbers = new Bag<>();
        while (!StdIn.isEmpty()) {
            numbers.add(StdIn.readDouble());
        }
        int n = numbers.size();

        // compute sample mean
        double sum = 0.0;
        for (double x : numbers) {
            sum += x;
        }
        double mean = sum/n;

        // compute sample standard deviation
        sum = 0.0;
        for (double x : numbers) {
            sum += (x - mean) * (x - mean);
        }
        double stddev = Math.sqrt(sum/(n-1));

        StdOut.printf("Mean:    %.2f\n", mean);
        StdOut.printf("Std dev: %.2f\n", stddev);
    }
}
```

从上面的代码中可以看出，背包的用法和数组很像，不过背包不能删除元素。

### 队列 FIFO

>  A *FIFO queue* is a collection that is based on the *first-in-first-out* (FIFO) policy. The policy of doing tasks in the same order that they arrive is one that we encounter frequently in everyday life: from people waiting in line at a theater, to cars waiting in line at a toll booth, to tasks waiting to be serviced by an application on your computer.

### 栈 stack

>  A *pushdown stack* is a collection that is based on the *last-in-first-out* (LIFO) policy. When you click a hyperlink, your browser displays the new page (and pushes onto a stack). You can keep clicking on hyperlinks to visit new pages, but you can always revisit the previous page by clicking the back button (popping it from the stack).

栈的应用如邮件，浏览器等，并且栈在计算机领域，有着基础而深远的影响，来看算数表达式求值(*Arithmetic expression evaluation* )的例子。

我们考虑计算机是如何来进行` ( 1+((2+3)*(4*5)))`

这时可以使用 Dijkstra‘s 2-stack algorithm

> A remarkably simple algorithm that was developed by E. W. Dijkstra in the 1960s uses two stacks (one for operands and one for operators) to do this job. An expression consists of parentheses, operators, and oper- ands (numbers). Proceeding from left to right and taking these entities one at a time, we manipulate the stacks according to four possible cases, as follows:
>
> - Push *operands*（运算元，即操作数） onto the operand stack.
> - Push *operators* （运算符）onto the operator stack.
> - Ignore *left* parentheses.
> - On encountering a *right* parenthesis, pop an operator, pop the requisite number
>
> of operands, and push onto the operand stack the result of applying that operator to those operands.

```java
public static void main(String[] args) {
  Stack<String> ops  = new Stack<>();
  Stack<Double> vals = new Stack<>();

  while (!StdIn.isEmpty()) {
    String s = StdIn.readString();
    if      (s.equals("("))               ;
    else if (s.equals("+"))    ops.push(s);
    else if (s.equals("-"))    ops.push(s);
    else if (s.equals("*"))    ops.push(s);
    else if (s.equals("/"))    ops.push(s);
    else if (s.equals("sqrt")) ops.push(s);
    else if (s.equals(")")) {
      String op = ops.pop();
      double v = vals.pop();
      if      (op.equals("+"))    v = vals.pop() + v;
      else if (op.equals("-"))    v = vals.pop() - v;
      else if (op.equals("*"))    v = vals.pop() * v;
      else if (op.equals("/"))    v = vals.pop() / v;
      else if (op.equals("sqrt")) v = Math.sqrt(v);
      vals.push(v);
    }
    else vals.push(Double.parseDouble(s));
  }
  StdOut.println(vals.pop());
}
```

以上代码运行过程为：

> `( 1 + ( ( 2 + 3 ) * ( 4 * 5 ) ) ) ( 1 + ( 5 * ( 4 * 5 ) ) )`
>  `( 1 + ( 5 * 20 ) )`
>  `( 1 + 100 )`
> `101`

## 集合类数据类型的实现

### 定容栈 Fixed-capacity Stack

### 泛型 Generic

### 调整数组大小 Array resizing

### 对象游离 Loitering

> Java’s garbage collection policy is to reclaim the memory associated with any objects that can no longer be accessed. In our pop() implementations, the reference to the popped item remains in the array. The item is effectively an *orphan*—it will never be accessed again—but the Java garbage collector has no way to know this until it is overwritten. Even when the client is done with the item, the reference in the array may keep it alive. This condition (holding a reference to an item that is no longer needed) is known as ***loitering***(游离). 

为了避免对象处于游离状态，可以 将其引用设为null

### 迭代 Iteration

## 链表 LinkedList

> **Definition.** A *linkedlist* is a recursive data structure that is either empty(*null*) or a reference to a *node* having a generic item and a reference to a linked list.
>
> 链表是一种递归的数据结构，它或者为空（null），或者是指向一个节点（node）的引用，该阶段含有一个泛型的元素和一个指向另一条链表的引用。