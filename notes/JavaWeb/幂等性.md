幂等性强调的是这个操作带来的影响，而不是说返回的结果要相同 GET， DELETE，PUT 是幂等的。POST不是幂等的



# 避免幂等性的方案

## 前端

- 按钮只可以操作一次

- token 机制，每次请求带上token，一判断重复操作

- 使用Post/Redirect/Get模式。即PRG，post之后立即重定向到get，这样刷新就不会重复post，也避免了浏览器重复提交警告

- session 中存放唯一表识

## 后端

- 使用唯一索引
- token + redis
  - 先请求token，将token放在 redis中
  - 第一次请求，检查redis中存在相同token，操作完删除，如果重复请求，检查redis时发现没有相同token，则为非法请求
- 状态机幂等：如将订单状态的转变设置为单向改变（不可逆），每次执行时要判断此时的状态是否满足要求，这样只有第一次的状态时满足的，第二次时由于状态单向的更改，因此再也不会成功。一般用于数据的更新中
- 乐观锁：通过version来做乐观锁，这样既能保证执行效率，也能保证幂等，version在更新操作中要自增: updatea xxx set money = money - 90, version = version + 1 where id = xx and version = 1;
  - 也可以使用带条件的乐观锁： update xxx. set quality = quality-#subuality# where id = 1 and quality-#subQuality# > 0 (这里不太能理解)
- 防重表：需要增加一个表来防止重复。使用唯一主键做防重表的唯一索引。比如使用订单号 orderNo 作为防重表的唯一索引，第一次在防重表中插入后，才可以支付，支付完成后可以将防重表中的数据删除，此时再要往里面查就会失败，因为唯一索引的原因？这里是将防重表作为锁来使用
- select + insert ：只适合单机没有并发的情况 ，该方案为操作之前先查询一下，符合要求再插入。并发时需要通过JVM锁来保证
- 分布式锁：在进入方法时，先获取锁，加入获取锁，就继续后面的流程，如果没有获得锁，就等到锁的释放直到获得锁。当然锁要设置超时时间。
- 缓冲队列：先将请求接受下来，放入缓存队列，后续使用异步任务队列中的数据，过滤掉重复请求，此方案的优点是同步该一步处理，高吞吐，不足是不能及时返回请求结果，需要后续轮询处理结果
- 全局唯一号

## 微服务

分布式锁可以把整个集群就当作是一个应用一样去处理，那么也就需要这个锁独立于每一个服务之外，而不是在服务里面。

